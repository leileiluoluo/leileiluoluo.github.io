<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>算法 on 磊磊落落</title><link>https://leileiluoluo.github.io/tags/%E7%AE%97%E6%B3%95/</link><description>Recent content in 算法 on 磊磊落落</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 18 Jul 2024 13:30:00 +0800</lastBuildDate><atom:link href="https://leileiluoluo.github.io/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>趣味算法题：从登录日志中计算各个用户的最长连续登录天数</title><link>https://leileiluoluo.github.io/posts/calculate-the-maximum-number-of-consecutive-login-days.html</link><pubDate>Thu, 18 Jul 2024 13:30:00 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/calculate-the-maximum-number-of-consecutive-login-days.html</guid><description>1 题目描述 假设我们有一个记录用户登录的日志文件，该文件有多行记录，每一行记录包含用户 ID、登录日期（格式为：yyyy-MM-dd）和登录时间（格式为：HH:mm:ss）三个以空格分割的条目。记录并不是以时间先后排序的，而是乱序的（如：样例输入中的记录 1002 2023-02-06 12:10:01 在 1002 2023-02-05 11:10:01 之前）。请计算每个用户的最长连续登录天数，输出格式为：用户 ID: 最长连续登录天数（如：样例输出中的 1002: 5）。</description></item><item><title>感知机算法及 Python 实现</title><link>https://leileiluoluo.github.io/posts/perceptron-python-implementation.html</link><pubDate>Sun, 01 May 2022 10:59:05 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/perceptron-python-implementation.html</guid><description>1 何为感知机？ 感知机是一个单层人工神经网络，是一个用于二分类的算法，其也是线性分类器的一种。
其可被抽象为下图所示模型：即一个神经元接收到来自 n 个其它神经元的输入信号；对这些输入信号，通过带权值的连接进行计算（各个连接线的权值与对应输入值相乘，然后进行累加），然后判断计算出来的累加值是否超过阈值（Threshold）；若等于或超过阈值，则输出 y 为 1，表示该神经元激活，否则输出 y 为 -1 表示该神经元抑制。</description></item><item><title>LeetCode 105 以先序遍历及中序遍历构造二叉树</title><link>https://leileiluoluo.github.io/posts/leetcode-construct-binary-tree-from-preorder-and-inorder-traversal.html</link><pubDate>Tue, 06 Oct 2020 19:07:00 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-construct-binary-tree-from-preorder-and-inorder-traversal.html</guid><description>1 题目描述 给定一棵二叉树的先序遍历及中序遍历，尝试构建该二叉树。
说明：
假定树中不存在值重复的情形 例如：</description></item><item><title>LeetCode 707 设计链表</title><link>https://leileiluoluo.github.io/posts/leetcode-design-linked-list.html</link><pubDate>Mon, 05 Oct 2020 12:09:28 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-design-linked-list.html</guid><description>1 题目描述 设计链表的实现。您可以选择使用单链表或者双链表来实现。
单链表中的节点应有val和next两个属性，val为当前节点的值，next为下一个节点的指针或引用。
若使用双链表实现，则需要一个额外的属性prev来指向当前节点的前一个节点。</description></item><item><title>LeetCode 94 二叉树中序遍历</title><link>https://leileiluoluo.github.io/posts/leetcode-binary-tree-inorder-traversal.html</link><pubDate>Sun, 26 Jul 2020 12:15:21 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-binary-tree-inorder-traversal.html</guid><description>1 题目描述 给定一棵二叉树，返回其节点值的中序遍历结果。
例如：
输入：[1,null,2,3] 1 \ 2 / 3 输出：[1,3,2] 注：递归较简单，您可否使用循环来实现？</description></item><item><title>LeetCode 92 反转链表 II</title><link>https://leileiluoluo.github.io/posts/leetcode-reverse-linked-list-ii.html</link><pubDate>Sat, 25 Jul 2020 10:00:10 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-reverse-linked-list-ii.html</guid><description>1 题目描述 对单链表的某一段（自第m个位置起到第n个位置止）进行反转。
例如：
输入：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 输出：1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL 注：1 ≤ m ≤ n ≤ length（链表长度）</description></item><item><title>LeetCode 206 反转链表</title><link>https://leileiluoluo.github.io/posts/leetcode-reverse-linked-list.html</link><pubDate>Fri, 24 Jul 2020 05:25:30 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-reverse-linked-list.html</guid><description>1 题目描述 对单链表进行反转。
例如：
输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 注：链表反转可使用循环或者递归方式实现，您能否同时实现此两种算法？</description></item><item><title>LeetCode 515 寻找二叉树每层的最大值</title><link>https://leileiluoluo.github.io/posts/leetcode-find-largest-value-in-each-tree-row.html</link><pubDate>Sun, 08 Mar 2020 00:51:33 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-find-largest-value-in-each-tree-row.html</guid><description>1 题目描述
该题目需要您找出二叉树中每一层的最大值，然后以数组返回。
例子：
输入：</description></item><item><title>LeetCode 701 二叉搜索树插入</title><link>https://leileiluoluo.github.io/posts/leetcode-insert-into-a-binary-search-tree.html</link><pubDate>Sun, 29 Dec 2019 10:11:09 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-insert-into-a-binary-search-tree.html</guid><description>1 题目描述
给定一个二叉搜索树（BST）的根节点及待插入值。请将该值插入到该二叉搜索树，然后返回值插入后的二叉搜索树。（注：待插入值在原二叉搜索树中不存在）
可能存在多种有效的插入方式，即只要在值插入后仍旧是二叉搜索树即可。您可以返回有效结果的任意一种。
例子：</description></item><item><title>LeetCode 103 二叉树Z字形层次遍历</title><link>https://leileiluoluo.github.io/posts/leetcode-binary-tree-zigzag-level-order-traversal.html</link><pubDate>Thu, 21 Nov 2019 11:26:31 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-binary-tree-zigzag-level-order-traversal.html</guid><description>1 题目描述
给定一个二叉树，返回其值的Z字形层次遍历。（如，先从左到右，下一层从右到左，以此类推，直至最后一层遍历完成）
例子：
输入：</description></item><item><title>LeetCode 1008 以先序遍历构建二叉搜索树</title><link>https://leileiluoluo.github.io/posts/leetcode-construct-binary-search-tree-from-preorder-traversal.html</link><pubDate>Sun, 17 Nov 2019 09:24:12 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-construct-binary-search-tree-from-preorder-traversal.html</guid><description>1 题目描述
以先序遍历构建二叉搜索树，并返回其根节点。
二叉搜索树是满足如下条件的二叉树：
对于每个节点，左子树node.left任意节点的值均小于node.val；右子树node.right任意节点的值均大于node.val。</description></item><item><title>LeetCode 889 以先序及后序遍历构建二叉树</title><link>https://leileiluoluo.github.io/posts/leetcode-construct-binary-tree-from-preorder-and-postorder-traversal.html</link><pubDate>Sun, 17 Nov 2019 01:03:54 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-construct-binary-tree-from-preorder-and-postorder-traversal.html</guid><description>1 题目描述
对于给定的先序及后序遍历，返回满足条件的任意二叉树。
注：
a）1 &amp;lt;= pre.</description></item><item><title>LeetCode 145 二叉树后序遍历</title><link>https://leileiluoluo.github.io/posts/leetcode-binary-tree-postorder-traversal.html</link><pubDate>Sat, 16 Nov 2019 01:31:35 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-binary-tree-postorder-traversal.html</guid><description>1 题目描述
给定一个二叉树，返回其节点值的后序遍历。
注：递归实现较简单，可以通过迭代实现吗。
例子：</description></item><item><title>LeetCode 106 根据中序遍历与后序遍历构造二叉树</title><link>https://leileiluoluo.github.io/posts/leetcode-construct-binary-tree-from-inorder-and-postorder-traversal.html</link><pubDate>Tue, 05 Nov 2019 12:10:27 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-construct-binary-tree-from-inorder-and-postorder-traversal.html</guid><description>1 题目描述
给定一个二叉树的中序遍历与后序遍历，请以此构造出该二叉树。
注：您可以假定该二叉树中不存在重复节点值。
例子：</description></item><item><title>LeetCode 513 找出二叉树左下角节点的值</title><link>https://leileiluoluo.github.io/posts/leetcode-find-bottom-left-tree-value.html</link><pubDate>Thu, 31 Oct 2019 11:17:36 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-find-bottom-left-tree-value.html</guid><description>1 题目描述
给定一个二叉树，找出最后一行最左边节点的值。
注：您可以假定给定的树非空。
例子1：</description></item><item><title>LeetCode 451 以出现频次排序字符</title><link>https://leileiluoluo.github.io/posts/leetcode-sort-characters-by-frequency.html</link><pubDate>Wed, 30 Oct 2019 12:27:55 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-sort-characters-by-frequency.html</guid><description>1 题目描述
给定一个字符串，请基于字符出现的频次将其倒序排列。
例子1：
输入：&amp;#34;tree&amp;#34; 输出：&amp;#34;eert&amp;#34; 释义：&amp;#39;e&amp;#39;出现2次，而&amp;#39;r&amp;#39;及&amp;#39;t&amp;#39;各出现1次，所以&amp;#39;e&amp;#39;应出现在&amp;#39;r&amp;#39;及&amp;#39;t&amp;#39;的前面，因此&amp;#34;eetr&amp;#34;是一个有效的答案。 例子2：</description></item><item><title>LeetCode 91 解码方式</title><link>https://leileiluoluo.github.io/posts/leetcode-decode-ways.html</link><pubDate>Mon, 28 Oct 2019 06:59:02 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-decode-ways.html</guid><description>1 题目描述
一段包含A-Z的文字使用如下映射关系加密为数字。
&amp;#39;A&amp;#39; -&amp;gt; 1 &amp;#39;B&amp;#39; -&amp;gt; 2 .</description></item><item><title>LeetCode 151 将字符串中的单词翻转</title><link>https://leileiluoluo.github.io/posts/leetcode-reverse-words-in-a-string.html</link><pubDate>Sun, 27 Oct 2019 08:59:49 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-reverse-words-in-a-string.html</guid><description>1 题目描述
给定一个字符串，将该字符串依序按单词进行翻转。
注：
a）单词被定义为连续的非空字符；</description></item><item><title>LeetCode 86 分割链表</title><link>https://leileiluoluo.github.io/posts/leetcode-partition-list.html</link><pubDate>Sun, 15 Sep 2019 03:04:30 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-partition-list.html</guid><description>1 题目描述
给定一个链表及一个值x，请以x分割链表以让小于x的节点出现在大于等于x的节点之前。
您须保证分割后的两部分仍保持原始链表的节点顺序。
例子：</description></item><item><title>LeetCode 508 高频子树和</title><link>https://leileiluoluo.github.io/posts/leetcode-most-frequent-subtree-sum.html</link><pubDate>Sat, 24 Aug 2019 15:11:02 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-most-frequent-subtree-sum.html</guid><description>1 题目描述
给您一颗二叉树，求出现次数最多的子树和。
一个节点的子树和的定义：根为该节点的所有子树节点值的总和（包含该根节点本身）。
所以，求一下出现次数最多的子树和是多少？若出现次数最多的子树和不唯一，请以任意顺序返回这些子树和的全部。</description></item></channel></rss>