<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on 磊磊落落</title><link>https://leileiluoluo.github.io/tags/golang/</link><description>Recent content in Golang on 磊磊落落</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 10 Jul 2024 10:00:00 +0800</lastBuildDate><atom:link href="https://leileiluoluo.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang 泛型编程初体验</title><link>https://leileiluoluo.github.io/posts/golang-generics.html</link><pubDate>Wed, 10 Jul 2024 10:00:00 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/golang-generics.html</guid><description>Go 1.18 加入了对泛型的支持。本文将使用切片反转和对象排序两个示例场景来演示泛型的使用。
开始前，我们先了解一下泛型的基本概念。
1 泛型是什么？ 泛型（Generics）是编程语言中的一种范式，其允许在定义类（Go 中的结构体）、接口和方法（函数）时使用类型参数（Type Parameters）。这些类型参数可以用来描述方法的参数类型或者类与接口的属性类型，从而使得代码可以在不同类型之间进行重用，而不必进行类型转换或使用 Object（Go 中的 interface{}）类型来处理。</description></item><item><title>Golang 1.22 对 for 循环作了两处更新</title><link>https://leileiluoluo.github.io/posts/golang-makes-two-changes-to-for-loops.html</link><pubDate>Fri, 15 Mar 2024 08:00:00 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/golang-makes-two-changes-to-for-loops.html</guid><description>&lt;p>Golang 有每半年发布一次版本的惯例，2024 年 2 月 6 号，Golang 在发布 1.21 半年后如期发布了 1.22 版本。其中在语言层面上，1.22 版本对 &lt;code>for&lt;/code> 循环作了两处更新。&lt;/p></description></item><item><title>使用 Golang 实现喜马拉雅音频下载</title><link>https://leileiluoluo.github.io/posts/ximalaya-audio-downloader.html</link><pubDate>Sat, 12 Nov 2022 08:00:00 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/ximalaya-audio-downloader.html</guid><description>「喜马拉雅」是本人非常喜欢的一款音频软件。里面有很多优质的音频节目，丰富了我的日常生活。
本文的诞生来自于我的个人需求：本人是喜马拉雅 APP 的重度用户，几乎每天都会使用其来听一些经典，它的确是给了我「每一天的精神食粮」。有时，有一些音频想下载下来反复听，但受限于手机的存储容量，不能随心将想听的音频进行下载。因此，便萌生了写点代码将音频下载到 U 盘，电脑或 MP3 设备的想法。</description></item><item><title>Golang 高效的字符串拼接方法</title><link>https://leileiluoluo.github.io/posts/efficent-string-concatenation-in-golang.html</link><pubDate>Sat, 03 Apr 2021 08:16:52 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/efficent-string-concatenation-in-golang.html</guid><description>日常编码中离不开字符串拼接，最常用的当属原生的拼接方式（+=）。但其在少量次数拼接中性能还可以，若进行大量的字符串拼接则应使用其它更高效的方式。
本文首先列出 Golang 中常用的几种字符串拼接方式，然后会对它们进行基准测试，以期阅读完本文，我们能对各种拼接方法的适用场景有一个基本了解。
1 字符串拼接有几种方法？ 孔乙己问：“回字有几种写法？”。我们在 Golang 使用中也难免会被问到：“字符串拼接有几种方法？”。下面就一一道来。</description></item><item><title>LeetCode 105 以先序遍历及中序遍历构造二叉树</title><link>https://leileiluoluo.github.io/posts/leetcode-construct-binary-tree-from-preorder-and-inorder-traversal.html</link><pubDate>Tue, 06 Oct 2020 19:07:00 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-construct-binary-tree-from-preorder-and-inorder-traversal.html</guid><description>1 题目描述 给定一棵二叉树的先序遍历及中序遍历，尝试构建该二叉树。
说明：
假定树中不存在值重复的情形 例如：</description></item><item><title>LeetCode 707 设计链表</title><link>https://leileiluoluo.github.io/posts/leetcode-design-linked-list.html</link><pubDate>Mon, 05 Oct 2020 12:09:28 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-design-linked-list.html</guid><description>1 题目描述 设计链表的实现。您可以选择使用单链表或者双链表来实现。
单链表中的节点应有val和next两个属性，val为当前节点的值，next为下一个节点的指针或引用。
若使用双链表实现，则需要一个额外的属性prev来指向当前节点的前一个节点。</description></item><item><title>Golang text/template 使用样例</title><link>https://leileiluoluo.github.io/posts/golang-text-template.html</link><pubDate>Sat, 03 Oct 2020 09:05:41 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/golang-text-template.html</guid><description>Golang text/template 包是一个数据驱动的模版渲染工具。提供条件判断，数组或 map 遍历；参数赋值，函数或方法调用；自定义函数扩展，模板嵌套及重用等功能。基于该工具，可以轻松实现复杂场景的文本渲染。如Helm Template基于此实现了功能强大的 Kubernetes 配置文件渲染工作。</description></item><item><title>LeetCode 94 二叉树中序遍历</title><link>https://leileiluoluo.github.io/posts/leetcode-binary-tree-inorder-traversal.html</link><pubDate>Sun, 26 Jul 2020 12:15:21 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-binary-tree-inorder-traversal.html</guid><description>1 题目描述 给定一棵二叉树，返回其节点值的中序遍历结果。
例如：
输入：[1,null,2,3] 1 \ 2 / 3 输出：[1,3,2] 注：递归较简单，您可否使用循环来实现？</description></item><item><title>LeetCode 92 反转链表 II</title><link>https://leileiluoluo.github.io/posts/leetcode-reverse-linked-list-ii.html</link><pubDate>Sat, 25 Jul 2020 10:00:10 +0800</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-reverse-linked-list-ii.html</guid><description>1 题目描述 对单链表的某一段（自第m个位置起到第n个位置止）进行反转。
例如：
输入：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 输出：1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL 注：1 ≤ m ≤ n ≤ length（链表长度）</description></item><item><title>LeetCode 206 反转链表</title><link>https://leileiluoluo.github.io/posts/leetcode-reverse-linked-list.html</link><pubDate>Fri, 24 Jul 2020 05:25:30 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-reverse-linked-list.html</guid><description>1 题目描述 对单链表进行反转。
例如：
输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 注：链表反转可使用循环或者递归方式实现，您能否同时实现此两种算法？</description></item><item><title>Golang 使用 Selenium 实现自动化测试初探</title><link>https://leileiluoluo.github.io/posts/golang-selenium.html</link><pubDate>Sat, 14 Mar 2020 00:00:16 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/golang-selenium.html</guid><description>Selenium 整合了一揽子工具与依赖库，支持 Web 浏览器自动化，提供一组扩展来模拟人与浏览器交互。我们基于其满足 W3C 标准的 WebDriver 来编写的自动化代码可在各种主流浏览器复用。</description></item><item><title>LeetCode 515 寻找二叉树每层的最大值</title><link>https://leileiluoluo.github.io/posts/leetcode-find-largest-value-in-each-tree-row.html</link><pubDate>Sun, 08 Mar 2020 00:51:33 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-find-largest-value-in-each-tree-row.html</guid><description>1 题目描述
该题目需要您找出二叉树中每一层的最大值，然后以数组返回。
例子：
输入：</description></item><item><title>LeetCode 701 二叉搜索树插入</title><link>https://leileiluoluo.github.io/posts/leetcode-insert-into-a-binary-search-tree.html</link><pubDate>Sun, 29 Dec 2019 10:11:09 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-insert-into-a-binary-search-tree.html</guid><description>1 题目描述
给定一个二叉搜索树（BST）的根节点及待插入值。请将该值插入到该二叉搜索树，然后返回值插入后的二叉搜索树。（注：待插入值在原二叉搜索树中不存在）
可能存在多种有效的插入方式，即只要在值插入后仍旧是二叉搜索树即可。您可以返回有效结果的任意一种。
例子：</description></item><item><title>LeetCode 103 二叉树Z字形层次遍历</title><link>https://leileiluoluo.github.io/posts/leetcode-binary-tree-zigzag-level-order-traversal.html</link><pubDate>Thu, 21 Nov 2019 11:26:31 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-binary-tree-zigzag-level-order-traversal.html</guid><description>1 题目描述
给定一个二叉树，返回其值的Z字形层次遍历。（如，先从左到右，下一层从右到左，以此类推，直至最后一层遍历完成）
例子：
输入：</description></item><item><title>LeetCode 1008 以先序遍历构建二叉搜索树</title><link>https://leileiluoluo.github.io/posts/leetcode-construct-binary-search-tree-from-preorder-traversal.html</link><pubDate>Sun, 17 Nov 2019 09:24:12 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-construct-binary-search-tree-from-preorder-traversal.html</guid><description>1 题目描述
以先序遍历构建二叉搜索树，并返回其根节点。
二叉搜索树是满足如下条件的二叉树：
对于每个节点，左子树node.left任意节点的值均小于node.val；右子树node.right任意节点的值均大于node.val。</description></item><item><title>LeetCode 889 以先序及后序遍历构建二叉树</title><link>https://leileiluoluo.github.io/posts/leetcode-construct-binary-tree-from-preorder-and-postorder-traversal.html</link><pubDate>Sun, 17 Nov 2019 01:03:54 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-construct-binary-tree-from-preorder-and-postorder-traversal.html</guid><description>1 题目描述
对于给定的先序及后序遍历，返回满足条件的任意二叉树。
注：
a）1 &amp;lt;= pre.</description></item><item><title>LeetCode 145 二叉树后序遍历</title><link>https://leileiluoluo.github.io/posts/leetcode-binary-tree-postorder-traversal.html</link><pubDate>Sat, 16 Nov 2019 01:31:35 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-binary-tree-postorder-traversal.html</guid><description>1 题目描述
给定一个二叉树，返回其节点值的后序遍历。
注：递归实现较简单，可以通过迭代实现吗。
例子：</description></item><item><title>LeetCode 106 根据中序遍历与后序遍历构造二叉树</title><link>https://leileiluoluo.github.io/posts/leetcode-construct-binary-tree-from-inorder-and-postorder-traversal.html</link><pubDate>Tue, 05 Nov 2019 12:10:27 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-construct-binary-tree-from-inorder-and-postorder-traversal.html</guid><description>1 题目描述
给定一个二叉树的中序遍历与后序遍历，请以此构造出该二叉树。
注：您可以假定该二叉树中不存在重复节点值。
例子：</description></item><item><title>LeetCode 513 找出二叉树左下角节点的值</title><link>https://leileiluoluo.github.io/posts/leetcode-find-bottom-left-tree-value.html</link><pubDate>Thu, 31 Oct 2019 11:17:36 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-find-bottom-left-tree-value.html</guid><description>1 题目描述
给定一个二叉树，找出最后一行最左边节点的值。
注：您可以假定给定的树非空。
例子1：</description></item><item><title>LeetCode 451 以出现频次排序字符</title><link>https://leileiluoluo.github.io/posts/leetcode-sort-characters-by-frequency.html</link><pubDate>Wed, 30 Oct 2019 12:27:55 +0000</pubDate><guid>https://leileiluoluo.github.io/posts/leetcode-sort-characters-by-frequency.html</guid><description>1 题目描述
给定一个字符串，请基于字符出现的频次将其倒序排列。
例子1：
输入：&amp;#34;tree&amp;#34; 输出：&amp;#34;eert&amp;#34; 释义：&amp;#39;e&amp;#39;出现2次，而&amp;#39;r&amp;#39;及&amp;#39;t&amp;#39;各出现1次，所以&amp;#39;e&amp;#39;应出现在&amp;#39;r&amp;#39;及&amp;#39;t&amp;#39;的前面，因此&amp;#34;eetr&amp;#34;是一个有效的答案。 例子2：</description></item></channel></rss>