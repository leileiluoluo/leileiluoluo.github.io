<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on 磊磊落落</title><link>https://leileiluoluo.com/tags/golang/</link><description>Recent content in Golang on 磊磊落落</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>leileiluoluo@leileiluoluo.com (磊磊落落)</managingEditor><webMaster>leileiluoluo@leileiluoluo.com (磊磊落落)</webMaster><lastBuildDate>Sat, 12 Nov 2022 08:00:00 +0800</lastBuildDate><atom:link href="https://leileiluoluo.com/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Golang 实现喜马拉雅音频下载</title><link>https://leileiluoluo.com/posts/ximalaya-audio-downloader.html</link><pubDate>Sat, 12 Nov 2022 08:00:00 +0800</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/ximalaya-audio-downloader.html</guid><description>「喜马拉雅」是本人非常喜欢的一款音频软件。里面有很多优质的音频节目，丰富了我的日常生活。
本文的诞生来自于我的个人需求：本人是喜马拉雅 APP 的重度用户，几乎每天都会使用其来听一些经典，它的确是给了我「每一天的精神食粮」。有时，有一些音频想下载下来反复听，但受限于手机的存储容量，不能随心将想听的音频进行下载。因此，便萌生了写点代码将音频下载到 U 盘，电脑或 MP3 设备的想法。</description></item><item><title>Golang 高效的字符串拼接方法</title><link>https://leileiluoluo.com/posts/efficent-string-concatenation-in-golang.html</link><pubDate>Sat, 03 Apr 2021 08:16:52 +0800</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/efficent-string-concatenation-in-golang.html</guid><description>日常编码中离不开字符串拼接，最常用的当属原生的拼接方式（+=）。但其在少量次数拼接中性能还可以，若进行大量的字符串拼接则应使用其它更高效的方式。
本文首先列出 Golang 中常用的几种字符串拼接方式，然后会对它们进行基准测试，以期阅读完本文，我们能对各种拼接方法的适用场景有一个基本了解。
1 字符串拼接有几种方法？ 孔乙己问：“回字有几种写法？”。我们在 Golang 使用中也难免会被问到：“字符串拼接有几种方法？”。下面就一一道来。</description></item><item><title>LeetCode 105 以先序遍历及中序遍历构造二叉树</title><link>https://leileiluoluo.com/posts/leetcode-construct-binary-tree-from-preorder-and-inorder-traversal.html</link><pubDate>Tue, 06 Oct 2020 19:07:00 +0800</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/leetcode-construct-binary-tree-from-preorder-and-inorder-traversal.html</guid><description>1 题目描述 给定一棵二叉树的先序遍历及中序遍历，尝试构建该二叉树。
说明：
假定树中不存在值重复的情形 例如：</description></item><item><title>LeetCode 707 设计链表</title><link>https://leileiluoluo.com/posts/leetcode-design-linked-list.html</link><pubDate>Mon, 05 Oct 2020 12:09:28 +0800</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/leetcode-design-linked-list.html</guid><description>1 题目描述 设计链表的实现。您可以选择使用单链表或者双链表来实现。
单链表中的节点应有val和next两个属性，val为当前节点的值，next为下一个节点的指针或引用。
若使用双链表实现，则需要一个额外的属性prev来指向当前节点的前一个节点。</description></item><item><title>Golang text/template 使用样例</title><link>https://leileiluoluo.com/posts/golang-text-template.html</link><pubDate>Sat, 03 Oct 2020 09:05:41 +0800</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/golang-text-template.html</guid><description>Golang text/template 包是一个数据驱动的模版渲染工具。提供条件判断，数组或 map 遍历；参数赋值，函数或方法调用；自定义函数扩展，模板嵌套及重用等功能。基于该工具，可以轻松实现复杂场景的文本渲染。如Helm Template基于此实现了功能强大的 Kubernetes 配置文件渲染工作。</description></item><item><title>LeetCode 94 二叉树中序遍历</title><link>https://leileiluoluo.com/posts/leetcode-binary-tree-inorder-traversal.html</link><pubDate>Sun, 26 Jul 2020 12:15:21 +0800</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/leetcode-binary-tree-inorder-traversal.html</guid><description>1 题目描述 给定一棵二叉树，返回其节点值的中序遍历结果。
例如：
输入：[1,null,2,3] 1 \ 2 / 3 输出：[1,3,2] 注：递归较简单，您可否使用循环来实现？</description></item><item><title>LeetCode 92 反转链表 II</title><link>https://leileiluoluo.com/posts/leetcode-reverse-linked-list-ii.html</link><pubDate>Sat, 25 Jul 2020 10:00:10 +0800</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/leetcode-reverse-linked-list-ii.html</guid><description>1 题目描述 对单链表的某一段（自第m个位置起到第n个位置止）进行反转。
例如：
输入：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 输出：1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL 注：1 ≤ m ≤ n ≤ length（链表长度）</description></item><item><title>LeetCode 206 反转链表</title><link>https://leileiluoluo.com/posts/leetcode-reverse-linked-list.html</link><pubDate>Fri, 24 Jul 2020 05:25:30 +0000</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/leetcode-reverse-linked-list.html</guid><description>1 题目描述 对单链表进行反转。
例如：
输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 注：链表反转可使用循环或者递归方式实现，您能否同时实现此两种算法？</description></item><item><title>Golang 使用 Selenium 实现自动化测试初探</title><link>https://leileiluoluo.com/posts/golang-selenium.html</link><pubDate>Sat, 14 Mar 2020 00:00:16 +0000</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/golang-selenium.html</guid><description>Selenium 整合了一揽子工具与依赖库，支持 Web 浏览器自动化，提供一组扩展来模拟人与浏览器交互。我们基于其满足 W3C 标准的 WebDriver 来编写的自动化代码可在各种主流浏览器复用。</description></item><item><title>LeetCode 515 寻找二叉树每层的最大值</title><link>https://leileiluoluo.com/posts/leetcode-find-largest-value-in-each-tree-row.html</link><pubDate>Sun, 08 Mar 2020 00:51:33 +0000</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/leetcode-find-largest-value-in-each-tree-row.html</guid><description>1 题目描述
该题目需要您找出二叉树中每一层的最大值，然后以数组返回。
例子：
输入：</description></item><item><title>LeetCode 701 二叉搜索树插入</title><link>https://leileiluoluo.com/posts/leetcode-insert-into-a-binary-search-tree.html</link><pubDate>Sun, 29 Dec 2019 10:11:09 +0000</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/leetcode-insert-into-a-binary-search-tree.html</guid><description>1 题目描述
给定一个二叉搜索树（BST）的根节点及待插入值。请将该值插入到该二叉搜索树，然后返回值插入后的二叉搜索树。（注：待插入值在原二叉搜索树中不存在）
可能存在多种有效的插入方式，即只要在值插入后仍旧是二叉搜索树即可。您可以返回有效结果的任意一种。
例子：</description></item><item><title>LeetCode 103 二叉树Z字形层次遍历</title><link>https://leileiluoluo.com/posts/leetcode-binary-tree-zigzag-level-order-traversal.html</link><pubDate>Thu, 21 Nov 2019 11:26:31 +0000</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/leetcode-binary-tree-zigzag-level-order-traversal.html</guid><description>1 题目描述
给定一个二叉树，返回其值的Z字形层次遍历。（如，先从左到右，下一层从右到左，以此类推，直至最后一层遍历完成）
例子：
输入：</description></item><item><title>LeetCode 1008 以先序遍历构建二叉搜索树</title><link>https://leileiluoluo.com/posts/leetcode-construct-binary-search-tree-from-preorder-traversal.html</link><pubDate>Sun, 17 Nov 2019 09:24:12 +0000</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/leetcode-construct-binary-search-tree-from-preorder-traversal.html</guid><description>1 题目描述
以先序遍历构建二叉搜索树，并返回其根节点。
二叉搜索树是满足如下条件的二叉树：
对于每个节点，左子树node.left任意节点的值均小于node.val；右子树node.right任意节点的值均大于node.val。</description></item><item><title>LeetCode 889 以先序及后序遍历构建二叉树</title><link>https://leileiluoluo.com/posts/leetcode-construct-binary-tree-from-preorder-and-postorder-traversal.html</link><pubDate>Sun, 17 Nov 2019 01:03:54 +0000</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/leetcode-construct-binary-tree-from-preorder-and-postorder-traversal.html</guid><description>1 题目描述
对于给定的先序及后序遍历，返回满足条件的任意二叉树。
注：
a）1 &amp;lt;= pre.</description></item><item><title>LeetCode 145 二叉树后序遍历</title><link>https://leileiluoluo.com/posts/leetcode-binary-tree-postorder-traversal.html</link><pubDate>Sat, 16 Nov 2019 01:31:35 +0000</pubDate><author>leileiluoluo@leileiluoluo.com (磊磊落落)</author><guid>https://leileiluoluo.com/posts/leetcode-binary-tree-postorder-traversal.html</guid><description>1 题目描述
给定一个二叉树，返回其节点值的后序遍历。
注：递归实现较简单，可以通过迭代实现吗。
例子：</description></item></channel></rss>