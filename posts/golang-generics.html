<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>Golang 泛型编程初体验 - 磊磊落落</title>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=keywords content="Golang,泛型"><meta name=description content="Go 1.18 加入了对泛型的支持。本文首先介绍了泛型的基本概念，然后使用切片反转和对象排序两个示例演示了泛型的使用。"><meta name=author content="磊磊落落"><meta name=generator content="Hugo 0.123.7"><link rel=stylesheet href=https://leileiluoluo.github.io/css/bootstrap.min.css><link rel=stylesheet href=https://leileiluoluo.github.io/css/themify-icons.css><link rel=stylesheet href=https://leileiluoluo.github.io/css/larry-custom-v1.6.css><link rel=stylesheet href=https://leileiluoluo.github.io/scss/style.min.css media=screen><link rel="shortcut icon" href=https://leileiluoluo.github.io/images/favicon.png type=image/x-icon><link rel=icon href=https://leileiluoluo.github.io/images/favicon.png type=image/x-icon><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?526723b767317055572c85bdb445353c",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><header class="fixed-top navigation"><div class=container><nav class="navbar navbar-expand-lg navbar-light bg-transparent"><a class=navbar-brand href=https://leileiluoluo.github.io/>磊磊落落</a>
<button class="navbar-toggler border-0" type=button data-toggle=collapse data-target=#navigation>
<i class="ti-menu h3"></i></button><div class="collapse navbar-collapse text-center" id=navigation><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/></a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E9%9A%8F%E7%AC%94/>随笔</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E8%AF%BB%E4%B9%A6/>读书</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E8%A7%82%E5%BD%B1/>观影</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E7%BB%83%E5%AD%97/>练字</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/about>关于</a></li></ul><div class=search><button id=searchOpen class=search-btn><i class=ti-search></i></button><div class=search-wrapper><form action=https://leileiluoluo.github.io//search class=h-100><input class="search-box px-4" id=search-query name=s type=search placeholder=键入关键字后回车...></form><button id=searchClose class=search-close><i class="ti-close text-dark"></i></button></div></div></div></nav></div></header><div class="py-5 d-none d-lg-block"></div><section class=section><div class=container><div class=row><div class="col-lg-8 mx-auto block shadow mb-5"><h1>Golang 泛型编程初体验</h1><div class="mb-3 post-meta">2024年07月10日
<a href=/categories/%e8%ae%a1%e7%ae%97%e6%9c%ba>计算机</a></div><div class="content mb-5"><p>Go 1.18 加入了对泛型的支持。本文将使用切片反转和对象排序两个示例场景来演示泛型的使用。</p><p>开始前，我们先了解一下泛型的基本概念。</p><h2 id=1-泛型是什么>1 泛型是什么？</h2><p>泛型（Generics）是编程语言中的一种范式，其允许在定义类（Go 中的结构体）、接口和方法（函数）时使用类型参数（Type Parameters）。这些类型参数可以用来描述方法的参数类型或者类与接口的属性类型，从而使得代码可以在不同类型之间进行重用，而不必进行类型转换或使用 Object（Go 中的 <code>interface{}</code>）类型来处理。</p><p>泛型最大的优势是提高了代码的重用性和类型安全性。通过泛型，可以编写出更加通用的类和方法，这些代码可以用于多种类型，从而省去了为每种类型都编写重复代码的情形。</p><p>接下来以切片反转和对象排序两个示例场景来演示泛型的使用。</p><h2 id=2-切片反转>2 切片反转</h2><p>下面以反转切片中的元素为例来演示泛型的使用，反转切片中的元素即是将切片中元素的顺序进行倒转，比如我们有一个 <code>int</code> 切片 <code>[]int{1, 2, 3, 4, 5}</code>，反转后的结果应为 <code>[]int{5, 4, 3, 2, 1}</code>。当然，可以执行反转的不止有 <code>int</code> 切片一种，理论上任何类型（包括所有基础类型和自定义结构体）的切片都可以进行反转，所以切片反转这个场景非常适合用来被改造为使用泛型的方式实现。</p><p>接下来即针对各种类型的切片，分析没有泛型前如何来实现反转，以及探索引入泛型后如何来进行通用化实现。</p><h3 id=21-使用泛型前>2.1 使用泛型前</h3><p>如果我们想对 <code>int</code> 切片进行反转，其实现可以是下面这样：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>ReverseInts</span>(a []<span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>for</span> i, j <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>, <span style=color:#0086b3>len</span>(a)<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>; i &lt; j; {
</span></span><span style=display:flex><span>        a[i], a[j] = a[j], a[i]
</span></span><span style=display:flex><span>        i<span style=color:#000;font-weight:700>++</span>
</span></span><span style=display:flex><span>        j<span style=color:#000;font-weight:700>--</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，我们使用 <code>ReverseInts()</code> 函数来对 <code>int</code> 切片中的元素进行反转。</p><p>实现逻辑是：</p><ul><li>声明两个变量 <code>i</code> 和 <code>j</code>，初始时分别指向切片中的首元素和尾元素；</li><li>在满足 <code>i &lt; j</code> 的情况下，交换首尾元素，交换后重新将 <code>i</code> 和 <code>j</code> 分别指向首元素的后一个元素和尾元素的前一个元素；</li><li>重复上一步，直至 <code>i >= j</code>，则所有元素交换完毕，整个切片完成反转。</li></ul><p>在 <code>main()</code> 函数中调用 <code>ReverseInts()</code> 函数对 <code>int</code> 切片进行反转的示例代码如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>ints <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>int</span>{<span style=color:#099>1</span>, <span style=color:#099>2</span>, <span style=color:#099>3</span>, <span style=color:#099>4</span>, <span style=color:#099>5</span>}
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>ReverseInts</span>(ints)
</span></span><span style=display:flex><span>fmt.<span style=color:#900;font-weight:700>Println</span>(ints) <span style=color:#998;font-style:italic>// [5 4 3 2 1]
</span></span></span></code></pre></div><p>输出结果满足预期。</p><p>如果我们想对 <code>string</code> 切片进行反转，其实现与上述对 <code>int</code> 切片进行反转的代码几乎一模一样（仅参数类型不同）：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>ReverseStrings</span>(a []<span style=color:#458;font-weight:700>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>for</span> i, j <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>, <span style=color:#0086b3>len</span>(a)<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>; i &lt; j; {
</span></span><span style=display:flex><span>        a[i], a[j] = a[j], a[i]
</span></span><span style=display:flex><span>        i<span style=color:#000;font-weight:700>++</span>
</span></span><span style=display:flex><span>        j<span style=color:#000;font-weight:700>--</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 <code>main()</code> 函数中调用 <code>ReverseStrings()</code> 函数对 <code>string</code> 切片进行反转的示例代码如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>strings <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>string</span>{<span style=color:#d14>&#34;a&#34;</span>, <span style=color:#d14>&#34;b&#34;</span>, <span style=color:#d14>&#34;c&#34;</span>, <span style=color:#d14>&#34;d&#34;</span>, <span style=color:#d14>&#34;e&#34;</span>}
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>ReverseStrings</span>(strings)
</span></span><span style=display:flex><span>fmt.<span style=color:#900;font-weight:700>Println</span>(strings) <span style=color:#998;font-style:italic>// [e d c b a]
</span></span></span></code></pre></div><p>除此之外，如果我们想对自定义结构体（如下面的 <code>student</code>）切片进行反转，该如何做呢？</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> student <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    id   <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>    name <span style=color:#458;font-weight:700>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其实现同样与前面的代码几乎完全一样：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>ReverseStudents</span>(a []student) {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>for</span> i, j <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>, <span style=color:#0086b3>len</span>(a)<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>; i &lt; j; {
</span></span><span style=display:flex><span>        a[i], a[j] = a[j], a[i]
</span></span><span style=display:flex><span>        i<span style=color:#000;font-weight:700>++</span>
</span></span><span style=display:flex><span>        j<span style=color:#000;font-weight:700>--</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// 调用 ReverseStudents() 函数对 student 切片进行反转
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>students <span style=color:#000;font-weight:700>:=</span> []student{
</span></span><span style=display:flex><span>    {id: <span style=color:#099>1</span>, name: <span style=color:#d14>&#34;Larry&#34;</span>},
</span></span><span style=display:flex><span>    {id: <span style=color:#099>2</span>, name: <span style=color:#d14>&#34;Jacky&#34;</span>},
</span></span><span style=display:flex><span>    {id: <span style=color:#099>3</span>, name: <span style=color:#d14>&#34;Alice&#34;</span>},
</span></span><span style=display:flex><span>    {id: <span style=color:#099>4</span>, name: <span style=color:#d14>&#34;Lucy&#34;</span>},
</span></span><span style=display:flex><span>    {id: <span style=color:#099>5</span>, name: <span style=color:#d14>&#34;Cindy&#34;</span>},
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>ReverseStudents</span>(students)
</span></span><span style=display:flex><span>fmt.<span style=color:#900;font-weight:700>Println</span>(students) <span style=color:#998;font-style:italic>// [{5 Cindy} {4 Lucy} {3 Alice} {2 Jacky} {1 Larry}]
</span></span></span></code></pre></div><p>所以，我们不禁要问：是否有一种泛型方式的写法，支持对任意类型的切片进行反转？</p><h3 id=22-使用泛型后>2.2 使用泛型后</h3><p>当然是有的，借助 Go 1.18 对泛型的支持，可以使用如下写法来对任意类型的切片进行反转：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> Reverse[T any](a []T) {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>for</span> i, j <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>, <span style=color:#0086b3>len</span>(a)<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>; i &lt; j; {
</span></span><span style=display:flex><span>        a[i], a[j] = a[j], a[i]
</span></span><span style=display:flex><span>        i<span style=color:#000;font-weight:700>++</span>
</span></span><span style=display:flex><span>        j<span style=color:#000;font-weight:700>--</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，与普通函数不同的是，如上 <code>Reverse()</code> 函数名后紧跟着一个使用中括号围起的类型参数（<code>[T any]</code>），该类型参数使用 <code>any</code> 约束，表示其可以为任意类型（<code>any</code> 为 <code>interface{}</code> 的别名，其定义为：<code>type any = interface{}</code>）；参数列表仅有一个参数 <code>a []T</code>，因 <code>T</code> 已在类型参数中定义，所以该参数 <code>a</code> 表示是一个任意类型的切片。</p><p>这样，在 <code>main()</code> 函数中，即可以调用 <code>Reverse()</code> 函数来对任意类型的切片进行反转了：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// 调用支持泛型的 Reverse() 函数对 float64 切片进行反转
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>floats <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>float64</span>{<span style=color:#099>1.03</span>, <span style=color:#099>2.25</span>, <span style=color:#099>3.38</span>, <span style=color:#099>4.49</span>, <span style=color:#099>5.52</span>}
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>Reverse</span>(floats) <span style=color:#998;font-style:italic>// Reverse[float64](floats)
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>fmt.<span style=color:#900;font-weight:700>Println</span>(floats) <span style=color:#998;font-style:italic>// [5.52 4.49 3.38 2.25 1.03]
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 调用支持泛型的 Reverse() 函数对 string 切片进行反转
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>strings <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>string</span>{<span style=color:#d14>&#34;a&#34;</span>, <span style=color:#d14>&#34;b&#34;</span>, <span style=color:#d14>&#34;c&#34;</span>, <span style=color:#d14>&#34;d&#34;</span>, <span style=color:#d14>&#34;e&#34;</span>}
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>Reverse</span>(strings) <span style=color:#998;font-style:italic>// Reverse[string](floats)
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>fmt.<span style=color:#900;font-weight:700>Println</span>(strings) <span style=color:#998;font-style:italic>// [e d c b a]
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 调用支持泛型的 Reverse() 函数对 student 切片进行反转
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>students <span style=color:#000;font-weight:700>:=</span> []student{
</span></span><span style=display:flex><span>    {id: <span style=color:#099>1</span>, name: <span style=color:#d14>&#34;Larry&#34;</span>},
</span></span><span style=display:flex><span>    {id: <span style=color:#099>2</span>, name: <span style=color:#d14>&#34;Jacky&#34;</span>},
</span></span><span style=display:flex><span>    {id: <span style=color:#099>3</span>, name: <span style=color:#d14>&#34;Alice&#34;</span>},
</span></span><span style=display:flex><span>    {id: <span style=color:#099>4</span>, name: <span style=color:#d14>&#34;Lucy&#34;</span>},
</span></span><span style=display:flex><span>    {id: <span style=color:#099>5</span>, name: <span style=color:#d14>&#34;Cindy&#34;</span>},
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>Reverse</span>(students) <span style=color:#998;font-style:italic>// Reverse[student](floats)
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>fmt.<span style=color:#900;font-weight:700>Println</span>(students) <span style=color:#998;font-style:italic>// [{5 Cindy} {4 Lucy} {3 Alice} {2 Jacky} {1 Larry}]
</span></span></span></code></pre></div><p>需要注意的是，调用泛型函数时可以使用方括号显式指定类型参数的类型，如：<code>Reverse[float64](floats)</code>、<code>Reverse[string](strings)</code> 和 <code>Reverse[student](students)</code>，这样编译器即可以将类型参数替换为指定的类型。但一般情况下，在调用时可以将其省略（如：<code>Reverse(floats)</code>、<code>Reverse(strings)</code> 和 <code>Reverse(students)</code>），这是因为 Go 通常是可以在编译期将类型参数的类型自行推断出来的。</p><h2 id=3-对象排序>3 对象排序</h2><p>接下来再借用对象排序这个常见的场景来演示泛型的使用。我们首先分别针对基础类型对象和自定义类型对象看一下在没有泛型前如何实现排序，然后探索引入泛型后如何实现通用化改造。</p><h3 id=31-使用泛型前>3.1 使用泛型前</h3><p>我们可以借助 Go 标准库的 <code>sort</code> 包来对对象切片进行排序。</p><h4 id=基础类型>基础类型</h4><p>针对基础类型切片，没有泛型前，要对切片中的元素进行排序时，需要分别调用 <code>sort</code> 包中对应类型的函数来实现。</p><p>示例代码如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// 调用 sort.Ints() 函数对 int 切片进行排序
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>ints <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>int</span>{<span style=color:#099>1</span>, <span style=color:#099>3</span>, <span style=color:#099>2</span>, <span style=color:#099>5</span>, <span style=color:#099>4</span>}
</span></span><span style=display:flex><span>sort.<span style=color:#900;font-weight:700>Ints</span>(ints)
</span></span><span style=display:flex><span>fmt.<span style=color:#900;font-weight:700>Println</span>(ints) <span style=color:#998;font-style:italic>// [1 2 3 4 5]
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 调用 sort.Float64s() 函数对 float64 切片进行排序
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>floats <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>float64</span>{<span style=color:#099>1.30</span>, <span style=color:#099>3.20</span>, <span style=color:#099>2.10</span>, <span style=color:#099>5.40</span>, <span style=color:#099>4.50</span>}
</span></span><span style=display:flex><span>sort.<span style=color:#900;font-weight:700>Float64s</span>(floats)
</span></span><span style=display:flex><span>fmt.<span style=color:#900;font-weight:700>Println</span>(floats) <span style=color:#998;font-style:italic>// [1.3 2.1 3.2 4.5 5.4]
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// 调用 sort.Strings() 函数对 string 切片进行排序
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>strings <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>string</span>{<span style=color:#d14>&#34;a&#34;</span>, <span style=color:#d14>&#34;e&#34;</span>, <span style=color:#d14>&#34;b&#34;</span>, <span style=color:#d14>&#34;d&#34;</span>, <span style=color:#d14>&#34;c&#34;</span>}
</span></span><span style=display:flex><span>sort.<span style=color:#900;font-weight:700>Strings</span>(strings)
</span></span><span style=display:flex><span>fmt.<span style=color:#900;font-weight:700>Println</span>(strings) <span style=color:#998;font-style:italic>// [a b c d e]
</span></span></span></code></pre></div><h4 id=自定义结构体类型>自定义结构体类型</h4><p>若是自定义结构体类型（如下面的 <code>student</code>），由其组成的切片该如何实现排序呢？</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> student <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    id   <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>    name <span style=color:#458;font-weight:700>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>要实现排序，该类型切片需要实现 <code>sort.Interface</code> 接口中定义的三个方法 <code>Len() int</code>、<code>Less(i, j int) bool</code> 和 <code>Swap(i, j int)</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> sortable []student
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s sortable) <span style=color:#900;font-weight:700>Len</span>() <span style=color:#458;font-weight:700>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> <span style=color:#0086b3>len</span>(s)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s sortable) <span style=color:#900;font-weight:700>Less</span>(i, j <span style=color:#458;font-weight:700>int</span>) <span style=color:#458;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> s[i].id &lt; s[j].id
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s sortable) <span style=color:#900;font-weight:700>Swap</span>(i, j <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>    s[i], s[j] = s[j], s[i]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样，即可在 <code>main()</code> 函数中调用 <code>sort.Sort()</code> 函数对 <code>student</code> 切片进行排序了：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>students <span style=color:#000;font-weight:700>:=</span> []student{
</span></span><span style=display:flex><span>    {id: <span style=color:#099>1</span>, name: <span style=color:#d14>&#34;Larry&#34;</span>},
</span></span><span style=display:flex><span>    {id: <span style=color:#099>3</span>, name: <span style=color:#d14>&#34;Jacky&#34;</span>},
</span></span><span style=display:flex><span>    {id: <span style=color:#099>2</span>, name: <span style=color:#d14>&#34;Lucy&#34;</span>},
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sort.<span style=color:#900;font-weight:700>Sort</span>(<span style=color:#900;font-weight:700>sortable</span>(students))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fmt.<span style=color:#900;font-weight:700>Println</span>(students) <span style=color:#998;font-style:italic>// [{1 Larry} {2 Lucy} {3 Jacky}]
</span></span></span></code></pre></div><p>介绍完在没有泛型特性前基础类型切片和自定义结构体类型切片实现排序的方法后，下面介绍一下引入泛型后，如何对它们分别进行通用化改造。</p><h3 id=32-使用泛型后>3.2 使用泛型后</h3><h4 id=基础类型-1>基础类型</h4><p>我们想设计一个泛型化的通用排序函数 <code>Sort()</code> 来支持对常用基础类型的切片进行排序：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> Sort[T Ordered](a []T) {
</span></span><span style=display:flex><span>    sort.<span style=color:#900;font-weight:700>Sort</span>(sortable[T](a))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>该函数类型参数使用的约束为 <code>Ordered</code>，其定义如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Ordered <span style=color:#000;font-weight:700>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a61717;background-color:#e3d2d2>~</span><span style=color:#458;font-weight:700>int</span> | <span style=color:#a61717;background-color:#e3d2d2>~</span><span style=color:#458;font-weight:700>int8</span> | <span style=color:#a61717;background-color:#e3d2d2>~</span><span style=color:#458;font-weight:700>int16</span> | <span style=color:#a61717;background-color:#e3d2d2>~</span><span style=color:#458;font-weight:700>int32</span> | <span style=color:#a61717;background-color:#e3d2d2>~</span><span style=color:#458;font-weight:700>int64</span> |
</span></span><span style=display:flex><span>    <span style=color:#a61717;background-color:#e3d2d2>~</span><span style=color:#458;font-weight:700>uint</span> | <span style=color:#a61717;background-color:#e3d2d2>~</span><span style=color:#458;font-weight:700>uint8</span> | <span style=color:#a61717;background-color:#e3d2d2>~</span><span style=color:#458;font-weight:700>uint16</span> | <span style=color:#a61717;background-color:#e3d2d2>~</span><span style=color:#458;font-weight:700>uint32</span> | <span style=color:#a61717;background-color:#e3d2d2>~</span><span style=color:#458;font-weight:700>uint64</span> | <span style=color:#a61717;background-color:#e3d2d2>~</span><span style=color:#458;font-weight:700>uintptr</span> |
</span></span><span style=display:flex><span>    <span style=color:#a61717;background-color:#e3d2d2>~</span><span style=color:#458;font-weight:700>float32</span> | <span style=color:#a61717;background-color:#e3d2d2>~</span><span style=color:#458;font-weight:700>float64</span> |
</span></span><span style=display:flex><span>    <span style=color:#a61717;background-color:#e3d2d2>~</span><span style=color:#458;font-weight:700>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，其支持 Go 标准库中几乎所有支持排序的基础类型（<code>~type</code> 表示支持 <code>type</code> 类型及其衍生类型）。</p><p>然后对泛型切片 <code>[]T</code> 起一个别名 <code>sortable</code>，并为 <code>sortable[T]</code> 实现 <code>Len() int</code>、<code>Less(i, j int) bool</code> 和 <code>Swap(i, j int)</code> 方法：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> sortable[T Ordered] []T
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s sortable[T]) <span style=color:#900;font-weight:700>Len</span>() <span style=color:#458;font-weight:700>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> <span style=color:#0086b3>len</span>(s)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s sortable[T]) <span style=color:#900;font-weight:700>Less</span>(i, j <span style=color:#458;font-weight:700>int</span>) <span style=color:#458;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> s[i] &lt; s[j]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s sortable[T]) <span style=color:#900;font-weight:700>Swap</span>(i, j <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>    s[i], s[j] = s[j], s[i]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样，即可以在 <code>main()</code> 函数中使用泛型函数 <code>Sort()</code> 来对任意基础类型进行排序了：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>ints <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>int</span>{<span style=color:#099>1</span>, <span style=color:#099>3</span>, <span style=color:#099>2</span>, <span style=color:#099>5</span>, <span style=color:#099>4</span>}
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>Sort</span>(ints)
</span></span><span style=display:flex><span>fmt.<span style=color:#900;font-weight:700>Println</span>(ints) <span style=color:#998;font-style:italic>// [1 2 3 4 5]
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span>floats <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>float64</span>{<span style=color:#099>1.30</span>, <span style=color:#099>3.20</span>, <span style=color:#099>2.10</span>, <span style=color:#099>5.40</span>, <span style=color:#099>4.50</span>}
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>Sort</span>(floats)
</span></span><span style=display:flex><span>fmt.<span style=color:#900;font-weight:700>Println</span>(floats) <span style=color:#998;font-style:italic>// [1.3 2.1 3.2 4.5 5.4]
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span>strings <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>string</span>{<span style=color:#d14>&#34;a&#34;</span>, <span style=color:#d14>&#34;e&#34;</span>, <span style=color:#d14>&#34;b&#34;</span>, <span style=color:#d14>&#34;d&#34;</span>, <span style=color:#d14>&#34;c&#34;</span>}
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>Sort</span>(strings)
</span></span><span style=display:flex><span>fmt.<span style=color:#900;font-weight:700>Println</span>(strings) <span style=color:#998;font-style:italic>// [a b c d e]
</span></span></span></code></pre></div><p>可以看到，泛型化的排序方法使用起来更加统一、简便。</p><h4 id=自定义结构体类型-1>自定义结构体类型</h4><p>刚刚我们针对基础类型，使用泛型化的实现方式对其切片进行排序时，可以看到 <code>Less(i, j int) bool</code> 方法的实现为 <code>s[i] &lt; s[j]</code>。而因 Go 没有操作符重载，所以 <code>Less(i, j int) bool</code> 方法仅对支持小于号运算符的基础类型适用，因此上述实现方式也无法适用到自定义结构体类型。</p><p>为了解决 <code>Less(i, j int) bool</code> 方法如何实现的问题，我们需要为自定义结构体类型定义一个公共接口 <code>Comparable</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Comparable[T any] <span style=color:#000;font-weight:700>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#900;font-weight:700>CompareTo</span>(T) <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>该接口是一个泛型接口，提供一个 <code>CompareTo(T) int</code> 方法来判断当前对象与传入对象的先后顺序（结果为正数表示当前对象靠后，为负数表示当前对象靠前，为 0 表示顺序一致），支持任意类型来使用。</p><p>这样，实现了该接口的自定义结构体类型均可以使用如下泛型方法进行排序：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> Sort[T Comparable[T]](a []T) {
</span></span><span style=display:flex><span>    sort.<span style=color:#900;font-weight:700>Sort</span>(sortable[T](a))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>同样，为泛型切片 <code>[]T</code> 定义别名 <code>sortable</code>，并为 <code>sortable[T]</code> 实现 <code>Len() int</code>、<code>Less(i, j int) bool</code> 和 <code>Swap(i, j int)</code> 方法的代码不能省略（特别注意下 <code>Less()</code> 方法的实现）：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> sortable[T Comparable[T]] []T
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s sortable[T]) <span style=color:#900;font-weight:700>Len</span>() <span style=color:#458;font-weight:700>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> <span style=color:#0086b3>len</span>(s)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s sortable[T]) <span style=color:#900;font-weight:700>Less</span>(i, j <span style=color:#458;font-weight:700>int</span>) <span style=color:#458;font-weight:700>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> s[i].<span style=color:#900;font-weight:700>CompareTo</span>(s[j]) &lt; <span style=color:#099>0</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s sortable[T]) <span style=color:#900;font-weight:700>Swap</span>(i, j <span style=color:#458;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>    s[i], s[j] = s[j], s[i]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样，任意一个自定义结构体，在实现了 <code>Comparable</code> 接口后，即可以使用我们设计的通用排序方法了：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> student <span style=color:#000;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>    id   <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>    name <span style=color:#458;font-weight:700>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s student) <span style=color:#900;font-weight:700>CompareTo</span>(other student) <span style=color:#458;font-weight:700>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> s.id <span style=color:#000;font-weight:700>-</span> other.id
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// 在 main() 函数中使用泛型函数 Sort() 对自定义对象 students 进行排序
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>students <span style=color:#000;font-weight:700>:=</span> []student{
</span></span><span style=display:flex><span>    {id: <span style=color:#099>1</span>, name: <span style=color:#d14>&#34;Larry&#34;</span>},
</span></span><span style=display:flex><span>    {id: <span style=color:#099>3</span>, name: <span style=color:#d14>&#34;Jacky&#34;</span>},
</span></span><span style=display:flex><span>    {id: <span style=color:#099>2</span>, name: <span style=color:#d14>&#34;Lucy&#34;</span>},
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#900;font-weight:700>Sort</span>(students)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fmt.<span style=color:#900;font-weight:700>Println</span>(students) <span style=color:#998;font-style:italic>// [{1 Larry} {2 Lucy} {3 Jacky}]
</span></span></span></code></pre></div><h2 id=4-小结>4 小结</h2><p>综上，本文首先介绍了泛型的基本概念，然后以切片反转和对象排序两个示例场景演示了 Go 泛型的使用。本文涉及的全部示例代码已提交至 <a href=https://github.com/leileiluoluo/go-exercises/tree/master/generics>GitHub</a>，欢迎关注或 Fork。</p><blockquote><p>参考资料</p><p>[1] Go Tutorial: Getting started with generics - <a href=https://go.dev/doc/tutorial/generics>https://go.dev/doc/tutorial/generics</a></p><p>[2] The Go Blog: Why Generics? - <a href=https://go.dev/blog/why-generics>https://go.dev/blog/why-generics</a></p><p>[3] Efficient Go: Generics, The Advanced Language Elements - <a href=https://www.oreilly.com/library/view/efficient-go/9781098105709/>https://www.oreilly.com/library/view/efficient-go/9781098105709/</a></p></blockquote></div><div class=content-footer><div class=weixinhao><img src=/static/images/self/weixinhao-white.jpg></div><div class=post-tags><a href=/tags/golang/>#Golang</a></div><div class=license><i class=ti-info-alt></i><div class=info>版权声明：该博客文章由作者通过「<a href=https://creativecommons.org/licenses/by/4.0/deed.zh>知识共享署名 4.0 许可证</a>」进行授权，转载须注明文章原始链接。</div></div></div></div><div class="col-lg-8 mx-auto block shadow"><h3>相关文章</h3><ul><li><a href=/posts/golang-makes-two-changes-to-for-loops.html>Golang 1.22 对 for 循环作了两处更新</a></li><li><a href=/posts/ximalaya-audio-downloader.html>使用 Golang 实现喜马拉雅音频下载</a></li><li><a href=/posts/efficent-string-concatenation-in-golang.html>Golang 高效的字符串拼接方法</a></li><li><a href=/posts/leetcode-construct-binary-tree-from-preorder-and-inorder-traversal.html>LeetCode 105 以先序遍历及中序遍历构造二叉树</a></li><li><a href=/posts/leetcode-design-linked-list.html>LeetCode 707 设计链表</a></li></ul></div><div class="col-lg-8 mx-auto block shadow"><div><h3>评论</h3><div id=comment-loading style=text-align:center;font-size:14px><img style=width:52px src=/static/images/site/mona-loading-default.gif>
<span>正在加载评论......</span></div><script>function handleMessage(e){if(e.origin!=="https://giscus.app")return;if(typeof e.data!="object"||!e.data.giscus)return;const t=document.getElementById("comment-loading");t.style.display="none"}window.addEventListener("message",handleMessage)</script><script src=https://giscus.app/client.js data-repo=leileiluoluo/leileiluoluo.github.io data-repo-id=R_kgDOJkLT8w data-category=General data-category-id=DIC_kwDOJkLT884CdtEh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></div></div></div></section><footer class="py-4 bg-lights border-top"><div class=container><div class="row justify-content-between text-center align-items-center"><div class="col-lg-4 text-center text-lg-left mb-4 mb-lg-0"></div><div class="col-lg-4 text-center mb-4 mb-lg-0"><ul class="list-inline mb-0"><li class=list-inline-item><a class="text-dark d-block p-2" href=https://leileiluoluo.github.io/sponsor>随喜打赏</a></li><li class=list-inline-item><a class="text-dark d-block p-2" href=https://leileiluoluo.github.io/about>关于本博</a></li><li class=list-inline-item><a class="text-dark d-block p-2" href=https://leileiluoluo.github.io/links>友情链接</a></li></ul></div><div class="col-lg-4 text-lg-right text-center mb-4 mb-lg-0"><ul class="list-inline social-icon mb-0"><li class=list-inline-item><a title=文章归档 href=/archives/><i class=ti-archive></i></a></li><li class=list-inline-item><a title=文章标签 href=/tags/><i class=ti-tag></i></a></li><li class=list-inline-item><a title="我的 GitHub" href=https://github.com/leileiluoluo><i class=ti-github></i></a></li><li class=list-inline-item><a title="网站 RSS" href=/index.xml><i class=ti-rss></i></a></li></ul></div></div><div style=text-align:center;font-size:18px;margin-bottom:22px><a style="-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-image:linear-gradient(to right,#14100f,#d55b5b,#4d14e6)" href=https://www.boyouquan.com/planet-shuttle>「博友圈 · 星球穿梭」</a></div><div class="text-center mt-4"><span>Made with <a href=https://gohugo.io/>Hugo</a> | Theme by <a href=https://github.com/themefisher/northendlab-hugo>NorthendLab</a> | <a href=https://beian.miit.gov.cn>辽ICP备2022012085号-5</a> | Copyright © 2017-2025</span></div></div></footer><script>var indexURL="https://leileiluoluo.github.io/index.json"</script><script src=https://leileiluoluo.github.io/js/jquery.min.js></script><script src=https://leileiluoluo.github.io/js/bootstrap.min.js></script><script src=https://leileiluoluo.github.io/js/fuse.min.js></script><script src=https://leileiluoluo.github.io/js/mark.js></script><script src=https://leileiluoluo.github.io/js/search.js></script><script src=https://leileiluoluo.github.io/js/script.min.js></script></body></html>