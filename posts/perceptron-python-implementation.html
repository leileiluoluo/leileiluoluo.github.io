<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>感知机算法及 Python 实现 - 磊磊落落</title>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=keywords content="Perceptron,感知机,机器学习,Python,算法"><meta name=description content="感知机 Perceptron 算法及 Python 实现。"><meta name=author content="磊磊落落"><meta name=generator content="Hugo 0.123.7"><link rel=stylesheet href=https://leileiluoluo.github.io/css/bootstrap.min.css><link rel=stylesheet href=https://leileiluoluo.github.io/css/themify-icons.css><link rel=stylesheet href=https://leileiluoluo.github.io/css/larry-custom-v1.6.css><link rel=stylesheet href=https://leileiluoluo.github.io/scss/style.min.css media=screen><link rel="shortcut icon" href=https://leileiluoluo.github.io/images/favicon.png type=image/x-icon><link rel=icon href=https://leileiluoluo.github.io/images/favicon.png type=image/x-icon><script type=text/javascript async src="/js/mathjax/2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:0 0!important;border:inherit;color:#515151}</style><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?526723b767317055572c85bdb445353c",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><header class="fixed-top navigation"><div class=container><nav class="navbar navbar-expand-lg navbar-light bg-transparent"><a class=navbar-brand href=https://leileiluoluo.github.io/>磊磊落落</a>
<button class="navbar-toggler border-0" type=button data-toggle=collapse data-target=#navigation>
<i class="ti-menu h3"></i></button><div class="collapse navbar-collapse text-center" id=navigation><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/></a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E9%9A%8F%E7%AC%94/>随笔</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E8%AF%BB%E4%B9%A6/>读书</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E8%A7%82%E5%BD%B1/>观影</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E7%BB%83%E5%AD%97/>练字</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/about>关于</a></li></ul><div class=search><button id=searchOpen class=search-btn><i class=ti-search></i></button><div class=search-wrapper><form action=https://leileiluoluo.github.io//search class=h-100><input class="search-box px-4" id=search-query name=s type=search placeholder=键入关键字后回车...></form><button id=searchClose class=search-close><i class="ti-close text-dark"></i></button></div></div></div></nav></div></header><div class="py-5 d-none d-lg-block"></div><section class=section><div class=container><div class=row><div class="col-lg-8 mx-auto block shadow mb-5"><h1>感知机算法及 Python 实现</h1><div class="mb-3 post-meta">2022年05月01日
<a href=/categories/%e8%ae%a1%e7%ae%97%e6%9c%ba>计算机</a></div><div class="content mb-5"><h3 id=1-何为感知机>1 何为感知机？</h3><p>感知机是一个单层人工神经网络，是一个用于二分类的算法，其也是线性分类器的一种。</p><p>其可被抽象为下图所示模型：即一个神经元接收到来自 n 个其它神经元的输入信号；对这些输入信号，通过带权值的连接进行计算（各个连接线的权值与对应输入值相乘，然后进行累加），然后判断计算出来的累加值是否超过阈值（Threshold）；若等于或超过阈值，则输出 y 为 1，表示该神经元激活，否则输出 y 为 -1 表示该神经元抑制。</p><p><img loading=lazy src=https://leileiluoluo.github.io/static/images/uploads/2022/05/perceptron.svg#center alt></p><p>所以，感知机模型可被描述为：</p><p>针对输入<code>$\boldsymbol x = \{x_{1}, x_{2}, ... , x_{n}\}$</code>，有 <code>$z = w_{1} x_{1} + w_{2} x_{2} + ... + w_{n} x_{n}$</code>，当<code>$z$</code>超过阈值<code>$\theta$</code>时，将其输出为 1，否则输出为 -1。即由符号函数<code>$f(z)$</code>来决定输出的类别。</p><p><code>$f(z)=\left\{\begin{matrix} 1, z\geq \theta &\\-1, z&lt; \theta \end{matrix}\right.$</code></p><p>下面，试着将<code>$\theta$</code>并入线性方程，让<code>$z$</code>看起来更紧凑一点：
<code>$z = w_{1} x_{1} + w_{2} x_{2} + ... + w_{n} x_{n} - \theta \\ z = w_{1} x_{1} + w_{2} x_{2} + ... + w_{n} x_{n} + (-\theta) \cdot 1$</code></p><p>这样，将<code>$-\theta$</code>当作<code>$w_{0}$</code>，1 当作<code>$x_{0}$</code>，上式即可变为：</p><p><code>$z = w_{0} x_{0} + w_{1} x_{1} + ... + w_{n} x_{n} = \boldsymbol{w}^T \boldsymbol{x}$</code></p><p>几何上为<code>$\boldsymbol{w}$</code>与<code>$\boldsymbol{x}$</code>两个向量的内积。</p><p>符号函数<code>$f(z)$</code>变为：
<code>$f(z)=\left\{\begin{matrix} 1, z\geq 0 &\\-1, z&lt; 0 \end{matrix}\right.$</code></p><h3 id=2-感知机学习算法>2 感知机学习算法</h3><p>原始的感知机学习策略比较简单，即对线性可分数据集（N 表示样本数）：</p><p><code>$T = \{(\boldsymbol x^{(1)}, y^{(1)}), (\boldsymbol x^{(2)}, y^{(2)}), ..., (\boldsymbol x^{(N)}, y^{(N)})\}$</code></p><ul><li>i) 将 n+1 维的权重向量<code>$\boldsymbol{w}$</code>初始化为一组随机非 0 值（不可全初始化为 0，否则，调整只会影响跨度不会改变方向）；</li><li>ii) 对每个 n+1 维的输入样例<code>$\boldsymbol{x}^{(i)}$</code>，根据<code>$f(z)$</code>计算其输出值<code>$\hat{y}^{(i)}$</code>，若其与真实值<code>$y^{(i)}$</code>不一致，则更新<code>$\boldsymbol{w}$</code>权重向量，即将<code>$\boldsymbol{w}$</code>中的每一个维度的值更新为<code>$w_{j}=w_{j}+\Delta w_{j}$</code>，增量<code>$\Delta w_{j}=\eta (y^{(i)} - \hat{y}^{(i)})x_{j}^{(i)}$</code>，其中<code>$0 &lt;\eta \leq 1$</code>为学习率，也称为步长；</li><li>iii) 循环直至所有样例均正确分类或达到最大循环次数退出循环。</li></ul><p>上述步骤 ii)中，增量<code>$\Delta w_{j}=\eta (y^{(i)} - \hat{y}^{(i)})x_{j}^{(i)}$</code>设置的非常巧妙。对输入样例<code>$\boldsymbol{x}^{(i)}$</code>，若计算值<code>$\hat{y}^{(i)}$</code>为 -1，真实值<code>$y^{(i)}$</code>为 1，增量<code>$\Delta w_{j}$</code>表示向正类靠近一点；反之，则向负类靠近一点；若计算值与真实值一致，则增量为 0。</p><h3 id=3-感知机学习算法的-python-实现>3 感知机学习算法的 Python 实现</h3><p>下面使用 Python 对如上感知机学习算法进行实现，Perceptron 类包含如下几个方法。</p><ul><li><code>__init__</code> 构造方法，新建 Perceptron 对象时可指定学习率 eta 及最大迭代次数 max_iter；</li><li><code>fit</code> 训练方法，首先，根据样本输入 x 的维度（若为 n），将权重向量 _w 初始化为一个 n+1 维的随机非 0 数值；然后，根据样本输入 x（N 个 n 维向量）及样本输出 y（N 个由 +1 或 -1 组成的数值）对权重向量 _w 进行调整，若在最大迭代次数 max_iter 内找到合适的 _w 可将样本数据集进行正确划分，则退出；否则，若已达到最大迭代次数仍未找到合适的 _w，则训练失败并退出；</li><li><code>_predict</code> 计算权重向量 _w 与某个样本输入 xi 向量点积的私有方法，返回值为 float 类型；</li><li><code>predict</code> 调用<code>_predict</code>算得两向量的点积后判断其是否非负，若非负返回 +1；否则返回 -1，返回值为 int 类型。该方法可供<code>fit</code>方法在训练时使用，亦可在训练成功后，使用其对新的输入进行预测。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ cat perceptron.py
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000;font-weight:700>from</span> <span style=color:#555>typing</span> <span style=color:#000;font-weight:700>import</span> List
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>random</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>class</span> <span style=color:#458;font-weight:700>Perceptron</span>:
</span></span><span style=display:flex><span>    <span style=color:#d14>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#d14>    Perceptron binary classifier
</span></span></span><span style=display:flex><span><span style=color:#d14>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>def</span> __init__(<span style=color:#999>self</span>, eta: <span style=color:#0086b3>float</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#099>1.0</span>, max_iter: <span style=color:#0086b3>int</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#099>1000</span>):
</span></span><span style=display:flex><span>        <span style=color:#d14>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#d14>        Perceptron constructor
</span></span></span><span style=display:flex><span><span style=color:#d14>        :param eta: 0 &lt; eta &lt;= 1.0
</span></span></span><span style=display:flex><span><span style=color:#d14>        :param max_iter: max iteration
</span></span></span><span style=display:flex><span><span style=color:#d14>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#999>self</span><span style=color:#000;font-weight:700>.</span>eta <span style=color:#000;font-weight:700>=</span> eta
</span></span><span style=display:flex><span>        <span style=color:#999>self</span><span style=color:#000;font-weight:700>.</span>max_iter <span style=color:#000;font-weight:700>=</span> max_iter
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        random<span style=color:#000;font-weight:700>.</span>seed(<span style=color:#099>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>def</span> <span style=color:#900;font-weight:700>fit</span>(<span style=color:#999>self</span>, x: List[List[<span style=color:#0086b3>float</span>]], y: List[<span style=color:#0086b3>int</span>]) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#000;font-weight:700>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#d14>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#d14>        Fit is used for data training
</span></span></span><span style=display:flex><span><span style=color:#d14>        after the execution, _w (weight vector) will be produced
</span></span></span><span style=display:flex><span><span style=color:#d14>        :param x: input, vector list
</span></span></span><span style=display:flex><span><span style=color:#d14>        :param y: output, class label list
</span></span></span><span style=display:flex><span><span style=color:#d14>        :return:  None
</span></span></span><span style=display:flex><span><span style=color:#d14>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>len</span>(x) <span style=color:#000;font-weight:700>&lt;=</span> <span style=color:#099>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#998;font-style:italic># initialize weight vector to random integers</span>
</span></span><span style=display:flex><span>        <span style=color:#999>self</span><span style=color:#000;font-weight:700>.</span>_w <span style=color:#000;font-weight:700>=</span> [random<span style=color:#000;font-weight:700>.</span>randint(<span style=color:#000;font-weight:700>-</span><span style=color:#099>10</span>, <span style=color:#099>10</span>) <span style=color:#000;font-weight:700>for</span> _ <span style=color:#000;font-weight:700>in</span> <span style=color:#0086b3>range</span>(<span style=color:#0086b3>len</span>(x[<span style=color:#099>0</span>]) <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        times <span style=color:#000;font-weight:700>=</span> <span style=color:#099>0</span>
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>while</span> times <span style=color:#000;font-weight:700>&lt;</span> <span style=color:#999>self</span><span style=color:#000;font-weight:700>.</span>max_iter:
</span></span><span style=display:flex><span>            times <span style=color:#000;font-weight:700>+=</span> <span style=color:#099>1</span>
</span></span><span style=display:flex><span>            errors <span style=color:#000;font-weight:700>=</span> <span style=color:#099>0</span>
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>for</span> xi, yi <span style=color:#000;font-weight:700>in</span> <span style=color:#0086b3>zip</span>(x, y):
</span></span><span style=display:flex><span>                y_predict <span style=color:#000;font-weight:700>=</span> <span style=color:#999>self</span><span style=color:#000;font-weight:700>.</span>predict(xi)
</span></span><span style=display:flex><span>                <span style=color:#000;font-weight:700>if</span> yi <span style=color:#000;font-weight:700>-</span> y_predict <span style=color:#000;font-weight:700>!=</span> <span style=color:#099>0</span>:
</span></span><span style=display:flex><span>                    errors <span style=color:#000;font-weight:700>+=</span> <span style=color:#099>1</span>
</span></span><span style=display:flex><span>                    <span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#0086b3>range</span>(<span style=color:#0086b3>len</span>(xi)):  <span style=color:#998;font-style:italic># update vector _w</span>
</span></span><span style=display:flex><span>                        <span style=color:#999>self</span><span style=color:#000;font-weight:700>.</span>_w[i <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>] <span style=color:#000;font-weight:700>+=</span> <span style=color:#999>self</span><span style=color:#000;font-weight:700>.</span>eta <span style=color:#000;font-weight:700>*</span> (yi <span style=color:#000;font-weight:700>-</span> y_predict) <span style=color:#000;font-weight:700>*</span> xi[i]
</span></span><span style=display:flex><span>                    <span style=color:#999>self</span><span style=color:#000;font-weight:700>.</span>_w[<span style=color:#099>0</span>] <span style=color:#000;font-weight:700>+=</span> <span style=color:#999>self</span><span style=color:#000;font-weight:700>.</span>eta <span style=color:#000;font-weight:700>*</span> (yi <span style=color:#000;font-weight:700>-</span> y_predict)
</span></span><span style=display:flex><span>                <span style=color:#0086b3>print</span>(<span style=color:#d14>&#39;times: </span><span style=color:#d14>{}</span><span style=color:#d14>, xi: </span><span style=color:#d14>{}</span><span style=color:#d14>, yi: </span><span style=color:#d14>{}</span><span style=color:#d14>, y_predict: </span><span style=color:#d14>{}</span><span style=color:#d14>, _w: </span><span style=color:#d14>{}</span><span style=color:#d14>&#39;</span><span style=color:#000;font-weight:700>.</span>format(times, xi, yi, y_predict, <span style=color:#999>self</span><span style=color:#000;font-weight:700>.</span>_w))
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>if</span> <span style=color:#099>0</span> <span style=color:#000;font-weight:700>==</span> errors:
</span></span><span style=display:flex><span>                <span style=color:#000;font-weight:700>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>def</span> <span style=color:#900;font-weight:700>_predict</span>(<span style=color:#999>self</span>, xi: List[<span style=color:#0086b3>float</span>]) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#0086b3>float</span>:
</span></span><span style=display:flex><span>        <span style=color:#d14>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#d14>        Calculate the predictive value for a single sample input xi
</span></span></span><span style=display:flex><span><span style=color:#d14>        :param x: a single sample input xi
</span></span></span><span style=display:flex><span><span style=color:#d14>        :return: dot product of vector _w and xi
</span></span></span><span style=display:flex><span><span style=color:#d14>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>return</span> <span style=color:#0086b3>sum</span>([<span style=color:#999>self</span><span style=color:#000;font-weight:700>.</span>_w[i <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>] <span style=color:#000;font-weight:700>*</span> xi[i] <span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> <span style=color:#0086b3>range</span>(<span style=color:#0086b3>len</span>(xi))]) <span style=color:#000;font-weight:700>+</span> <span style=color:#999>self</span><span style=color:#000;font-weight:700>.</span>_w[<span style=color:#099>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>def</span> <span style=color:#900;font-weight:700>predict</span>(<span style=color:#999>self</span>, xi: List[<span style=color:#0086b3>float</span>]) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#0086b3>int</span>:
</span></span><span style=display:flex><span>        <span style=color:#d14>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#d14>        Predict xi belongs to class +1 or -1
</span></span></span><span style=display:flex><span><span style=color:#d14>        :param xi: a single sample input xi
</span></span></span><span style=display:flex><span><span style=color:#d14>        :return: class +1 or -1
</span></span></span><span style=display:flex><span><span style=color:#d14>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>return</span> <span style=color:#099>1</span> <span style=color:#000;font-weight:700>if</span> <span style=color:#999>self</span><span style=color:#000;font-weight:700>.</span>_predict(xi) <span style=color:#000;font-weight:700>&gt;=</span> <span style=color:#099>0</span> <span style=color:#000;font-weight:700>else</span> <span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>
</span></span></code></pre></div><p>下面使用该 Perceptron 模型对仅有两个维度的样本输入 X={(3, 3), (4, 3), (1, 1)}，输出 Y={1, 1, -1}进行划分：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ cat test.py
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#998;font-style:italic>#!/usr/bin/env python3</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>perceptron</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>if</span> <span style=color:#d14>&#39;__main__&#39;</span> <span style=color:#000;font-weight:700>==</span> __name__:
</span></span><span style=display:flex><span>    p <span style=color:#000;font-weight:700>=</span> perceptron<span style=color:#000;font-weight:700>.</span>Perceptron(eta<span style=color:#000;font-weight:700>=</span><span style=color:#099>1.0</span>, max_iter<span style=color:#000;font-weight:700>=</span><span style=color:#099>100</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    x <span style=color:#000;font-weight:700>=</span> [[<span style=color:#099>3</span>, <span style=color:#099>3</span>], [<span style=color:#099>4</span>, <span style=color:#099>3</span>], [<span style=color:#099>1</span>, <span style=color:#099>1</span>]]
</span></span><span style=display:flex><span>    y <span style=color:#000;font-weight:700>=</span> [<span style=color:#099>1</span>, <span style=color:#099>1</span>, <span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>]
</span></span><span style=display:flex><span>    p<span style=color:#000;font-weight:700>.</span>fit(x, y)
</span></span></code></pre></div><p>根据如下打印结果可以看到，该算法经过 3 轮，6 次判断，3 次权重调整后得到一个可将样本数据正确划分的权重向量 [-8.0, 10.0, -6.0]。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>times: 1, xi: [3, 3], yi: 1, y_predict: -1, _w: [-4.0, 14.0, -2.0]
</span></span><span style=display:flex><span>times: 1, xi: [4, 3], yi: 1, y_predict: 1, _w: [-4.0, 14.0, -2.0]
</span></span><span style=display:flex><span>times: 1, xi: [1, 1], yi: -1, y_predict: 1, _w: [-6.0, 12.0, -4.0]
</span></span><span style=display:flex><span>times: 2, xi: [3, 3], yi: 1, y_predict: 1, _w: [-6.0, 12.0, -4.0]
</span></span><span style=display:flex><span>times: 2, xi: [4, 3], yi: 1, y_predict: 1, _w: [-6.0, 12.0, -4.0]
</span></span><span style=display:flex><span>times: 2, xi: [1, 1], yi: -1, y_predict: 1, _w: [-8.0, 10.0, -6.0]
</span></span><span style=display:flex><span>times: 3, xi: [3, 3], yi: 1, y_predict: 1, _w: [-8.0, 10.0, -6.0]
</span></span><span style=display:flex><span>times: 3, xi: [4, 3], yi: 1, y_predict: 1, _w: [-8.0, 10.0, -6.0]
</span></span><span style=display:flex><span>times: 3, xi: [1, 1], yi: -1, y_predict: -1, _w: [-8.0, 10.0, -6.0]
</span></span></code></pre></div><p>因该样例的样本点是二维的，所以可将其表示为平面空间的点，权重向量为一条直线。寻找权重向量的过程如下图所示。</p><p><img loading=lazy src=https://leileiluoluo.github.io/static/images/uploads/2022/05/perceptron-2d-example.gif#center alt></p><h3 id=4-对-iris-数据集进行训练及预测>4 对 Iris 数据集进行训练及预测</h3><p>下面使用 3 中的代码对<a href=https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data>iris(鸢尾花)</a>数据集进行训练及预测。该数据集共包含三类鸢尾花品种，因 Perceptron 模型是一个仅支持二分类的分类器。所以仅选取该数据集中的两类数据（Iris-setosa 与 Iris-versicolor）进行训练及预测（该两类数据均有 50 条，分别取两者的前 40 条作为训练样本，两者的后 10 条作为预测样本）。</p><p>测试代码，测试数据，与 Perceptron 模型代码（perceptron.py）的目录结构如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ tree .
</span></span><span style=display:flex><span>perceptron.py
</span></span><span style=display:flex><span>test.py
</span></span><span style=display:flex><span>iris.data
</span></span><span style=display:flex><span>predict.data
</span></span></code></pre></div><p><code>iris.data</code>的内容如下（每一行的数值表示：萼长 - Sepal length、萼宽 - Sepal width、瓣长 - Petal length、瓣宽 - Petal width、花的种类）：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>5.1,3.5,1.4,0.2,Iris-setosa
</span></span><span style=display:flex><span>4.9,3.0,1.4,0.2,Iris-setosa
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>7.0,3.2,4.7,1.4,Iris-versicolor
</span></span><span style=display:flex><span>6.4,3.2,4.5,1.5,Iris-versicolor
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>调用 Perceptron 的代码如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ cat test.py
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#998;font-style:italic>#!/usr/bin/env python3</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>perceptron</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>csv</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>if</span> <span style=color:#d14>&#39;__main__&#39;</span> <span style=color:#000;font-weight:700>==</span> __name__:
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic># perceptron instance</span>
</span></span><span style=display:flex><span>    p <span style=color:#000;font-weight:700>=</span> perceptron<span style=color:#000;font-weight:700>.</span>Perceptron(eta<span style=color:#000;font-weight:700>=</span><span style=color:#099>1.0</span>, max_iter<span style=color:#000;font-weight:700>=</span><span style=color:#099>100</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic># training</span>
</span></span><span style=display:flex><span>    x <span style=color:#000;font-weight:700>=</span> []
</span></span><span style=display:flex><span>    y <span style=color:#000;font-weight:700>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>with</span> <span style=color:#0086b3>open</span>(<span style=color:#d14>&#39;iris.data&#39;</span>) <span style=color:#000;font-weight:700>as</span> f:
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>for</span> sample <span style=color:#000;font-weight:700>in</span> csv<span style=color:#000;font-weight:700>.</span>reader(f):
</span></span><span style=display:flex><span>            x<span style=color:#000;font-weight:700>.</span>append([<span style=color:#0086b3>float</span>(i) <span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> sample[:<span style=color:#099>4</span>]])
</span></span><span style=display:flex><span>            y<span style=color:#000;font-weight:700>.</span>append(<span style=color:#099>1</span> <span style=color:#000;font-weight:700>if</span> sample[<span style=color:#099>4</span>] <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;Iris-setosa&#39;</span> <span style=color:#000;font-weight:700>else</span> <span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>)
</span></span><span style=display:flex><span>    p<span style=color:#000;font-weight:700>.</span>fit(x, y)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#998;font-style:italic># predict</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>with</span> <span style=color:#0086b3>open</span>(<span style=color:#d14>&#39;predict.data&#39;</span>) <span style=color:#000;font-weight:700>as</span> f:
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>for</span> sample <span style=color:#000;font-weight:700>in</span> csv<span style=color:#000;font-weight:700>.</span>reader(f):
</span></span><span style=display:flex><span>            xi, yi <span style=color:#000;font-weight:700>=</span> [<span style=color:#0086b3>float</span>(i) <span style=color:#000;font-weight:700>for</span> i <span style=color:#000;font-weight:700>in</span> sample[:<span style=color:#099>4</span>]], sample[<span style=color:#099>4</span>]
</span></span><span style=display:flex><span>            <span style=color:#0086b3>print</span>(<span style=color:#d14>&#39;predict label: </span><span style=color:#d14>{}</span><span style=color:#d14>, real: </span><span style=color:#d14>{}</span><span style=color:#d14>&#39;</span><span style=color:#000;font-weight:700>.</span>format(p<span style=color:#000;font-weight:700>.</span>predict(xi), yi))
</span></span></code></pre></div><p>观察输出可以发现，该 Perceptron 算法经过 7 轮迭代找到合适的权重向量，然后采用训练的模型对 20 条测试数据进行预测，结果准确无误。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>...
</span></span><span style=display:flex><span>predict label: 1, real: Iris-setosa
</span></span><span style=display:flex><span>predict label: 1, real: Iris-setosa
</span></span><span style=display:flex><span>predict label: 1, real: Iris-setosa
</span></span><span style=display:flex><span>predict label: 1, real: Iris-setosa
</span></span><span style=display:flex><span>predict label: 1, real: Iris-setosa
</span></span><span style=display:flex><span>predict label: 1, real: Iris-setosa
</span></span><span style=display:flex><span>predict label: 1, real: Iris-setosa
</span></span><span style=display:flex><span>predict label: 1, real: Iris-setosa
</span></span><span style=display:flex><span>predict label: 1, real: Iris-setosa
</span></span><span style=display:flex><span>predict label: 1, real: Iris-setosa
</span></span><span style=display:flex><span>predict label: -1, real: Iris-versicolor
</span></span><span style=display:flex><span>predict label: -1, real: Iris-versicolor
</span></span><span style=display:flex><span>predict label: -1, real: Iris-versicolor
</span></span><span style=display:flex><span>predict label: -1, real: Iris-versicolor
</span></span><span style=display:flex><span>predict label: -1, real: Iris-versicolor
</span></span><span style=display:flex><span>predict label: -1, real: Iris-versicolor
</span></span><span style=display:flex><span>predict label: -1, real: Iris-versicolor
</span></span><span style=display:flex><span>predict label: -1, real: Iris-versicolor
</span></span><span style=display:flex><span>predict label: -1, real: Iris-versicolor
</span></span><span style=display:flex><span>predict label: -1, real: Iris-versicolor
</span></span></code></pre></div><p>综上，对感知机算法的原理作了学习与了解，并使用 Python 对其进行了实现及初步应用。本文代码已托管至<a href=https://github.com/leileiluoluo/machine-learning/tree/main/perceptron>GitHub</a>，欢迎 Fork。</p><blockquote><p>参考资料</p><p>[1] Sebastian & Vahid. Python Machine Learning (Second Edition).</p><p>[2] 李航.(2012). 统计学习方法(第 2 版). 清华大学出版社, 北京.</p></blockquote></div><div class=content-footer><div class=weixinhao><img src=/static/images/self/weixinhao-white.jpg></div><div class=post-tags><a href=/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>#机器学习</a>
<a href=/tags/python/>#Python</a>
<a href=/tags/%E7%AE%97%E6%B3%95/>#算法</a></div><div class=license><i class=ti-info-alt></i><div class=info>版权声明：该博客文章由作者通过「<a href=https://creativecommons.org/licenses/by/4.0/deed.zh>知识共享署名 4.0 许可证</a>」进行授权，转载须注明文章原始链接。</div></div></div></div><div class="col-lg-8 mx-auto block shadow"><h3>相关文章</h3><ul><li><a href=/posts/kdtree-algorithm-and-implementation.html>k-d tree算法原理及实现</a></li><li><a href=/posts/leetcode-construct-binary-tree-from-preorder-and-inorder-traversal.html>LeetCode 105 以先序遍历及中序遍历构造二叉树</a></li><li><a href=/posts/leetcode-design-linked-list.html>LeetCode 707 设计链表</a></li><li><a href=/leetcode-golang-implementations/>LeetCode 题目Golang实现汇总</a></li><li><a href=/posts/selenium-grid.html>Selenium Grid 搭建及使用</a></li></ul></div><div class="col-lg-8 mx-auto block shadow"><div><h3>评论</h3><div id=comment-loading style=text-align:center;font-size:14px><img style=width:52px src=/static/images/site/mona-loading-default.gif>
<span>正在加载评论......</span></div><script>function handleMessage(e){if(e.origin!=="https://giscus.app")return;if(typeof e.data!="object"||!e.data.giscus)return;const t=document.getElementById("comment-loading");t.style.display="none"}window.addEventListener("message",handleMessage)</script><script src=https://giscus.app/client.js data-repo=leileiluoluo/leileiluoluo.github.io data-repo-id=R_kgDOJkLT8w data-category=General data-category-id=DIC_kwDOJkLT884CdtEh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></div></div></div></section><footer class="py-4 bg-lights border-top"><div class=container><div class="row justify-content-between text-center align-items-center"><div class="col-lg-4 text-center text-lg-left mb-4 mb-lg-0"></div><div class="col-lg-4 text-center mb-4 mb-lg-0"><ul class="list-inline mb-0"><li class=list-inline-item><a class="text-dark d-block p-2" href=https://leileiluoluo.github.io/sponsor>随喜打赏</a></li><li class=list-inline-item><a class="text-dark d-block p-2" href=https://leileiluoluo.github.io/about>关于本博</a></li><li class=list-inline-item><a class="text-dark d-block p-2" href=https://leileiluoluo.github.io/links>友情链接</a></li></ul></div><div class="col-lg-4 text-lg-right text-center mb-4 mb-lg-0"><ul class="list-inline social-icon mb-0"><li class=list-inline-item><a title=文章归档 href=/archives/><i class=ti-archive></i></a></li><li class=list-inline-item><a title=文章标签 href=/tags/><i class=ti-tag></i></a></li><li class=list-inline-item><a title="我的 GitHub" href=https://github.com/leileiluoluo><i class=ti-github></i></a></li><li class=list-inline-item><a title="网站 RSS" href=/index.xml><i class=ti-rss></i></a></li></ul></div></div><div style=text-align:center;font-size:18px;margin-bottom:22px><a style="-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-image:linear-gradient(to right,#14100f,#d55b5b,#4d14e6)" href=https://www.boyouquan.com/planet-shuttle>「博友圈 · 星球穿梭」</a></div><div class="text-center mt-4"><span>Made with <a href=https://gohugo.io/>Hugo</a> | Theme by <a href=https://github.com/themefisher/northendlab-hugo>NorthendLab</a> | <a href=https://beian.miit.gov.cn>辽ICP备2022012085号-5</a> | Copyright © 2017-2025</span></div></div></footer><script>var indexURL="https://leileiluoluo.github.io/index.json"</script><script src=https://leileiluoluo.github.io/js/jquery.min.js></script><script src=https://leileiluoluo.github.io/js/bootstrap.min.js></script><script src=https://leileiluoluo.github.io/js/fuse.min.js></script><script src=https://leileiluoluo.github.io/js/mark.js></script><script src=https://leileiluoluo.github.io/js/search.js></script><script src=https://leileiluoluo.github.io/js/script.min.js></script></body></html>