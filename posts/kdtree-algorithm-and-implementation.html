<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>k-d tree算法原理及实现 - 磊磊落落</title>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=keywords content="Java,Golang,Python,云原生,架构设计,DevOps,自动化测试,技术博客,生活博客"><meta name=description content="我是浩然，一名软件开发工程师，我的博客「磊磊落落」建立于 2017 年，是我用于记录内心波澜，分享读书感想，思考人生哲学，关注社会百态，梳理计算机专业知识的纯原创站点。目前我在技术上主要关注：Java、Golang、Python、前端开发、云原生、架构设计、DevOps 和自动化测试。"><meta name=author content="磊磊落落"><meta name=generator content="Hugo 0.123.7"><link rel=stylesheet href=https://leileiluoluo.github.io/css/bootstrap.min.css><link rel=stylesheet href=https://leileiluoluo.github.io/css/themify-icons.css><link rel=stylesheet href=https://leileiluoluo.github.io/css/larry-custom-v1.6.css><link rel=stylesheet href=https://leileiluoluo.github.io/scss/style.min.css media=screen><link rel="shortcut icon" href=https://leileiluoluo.github.io/images/favicon.png type=image/x-icon><link rel=icon href=https://leileiluoluo.github.io/images/favicon.png type=image/x-icon><script type=text/javascript async src="/js/mathjax/2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:0 0!important;border:inherit;color:#515151}</style><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?526723b767317055572c85bdb445353c",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><header class="fixed-top navigation"><div class=container><nav class="navbar navbar-expand-lg navbar-light bg-transparent"><a class=navbar-brand href=https://leileiluoluo.github.io/>磊磊落落</a>
<button class="navbar-toggler border-0" type=button data-toggle=collapse data-target=#navigation>
<i class="ti-menu h3"></i></button><div class="collapse navbar-collapse text-center" id=navigation><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/></a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E9%9A%8F%E7%AC%94/>随笔</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E8%AF%BB%E4%B9%A6/>读书</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E8%A7%82%E5%BD%B1/>观影</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/categories/%E7%BB%83%E5%AD%97/>练字</a></li><li class=nav-item><a class=nav-link href=https://leileiluoluo.github.io/about>关于</a></li></ul><div class=search><button id=searchOpen class=search-btn><i class=ti-search></i></button><div class=search-wrapper><form action=https://leileiluoluo.github.io//search class=h-100><input class="search-box px-4" id=search-query name=s type=search placeholder=键入关键字后回车...></form><button id=searchClose class=search-close><i class="ti-close text-dark"></i></button></div></div></div></nav></div></header><div class="py-5 d-none d-lg-block"></div><section class=section><div class=container><div class=row><div class="col-lg-8 mx-auto block shadow mb-5"><h1>k-d tree算法原理及实现</h1><div class="mb-3 post-meta">2017年12月28日
<a href=/categories/%e8%ae%a1%e7%ae%97%e6%9c%ba>计算机</a></div><div class="content mb-5"><p>k-d tree即k-dimensional tree，常用来作空间划分及近邻搜索，是二叉空间划分树的一个特例。通常，对于维度为<code>$k$</code>，数据点数为<code>$N$</code>的数据集，k-d tree适用于<code>$N\gg2^k$</code>的情形。</p><p><strong>1）k-d tree算法原理</strong></p><p>k-d tree是每个节点均为k维数值点的二叉树，其上的每个节点代表一个超平面，该超平面垂直于当前划分维度的坐标轴，并在该维度上将空间划分为两部分，一部分在其左子树，另一部分在其右子树。即若当前节点的划分维度为d，其左子树上所有点在d维的坐标值均小于当前值，右子树上所有点在d维的坐标值均大于等于当前值，本定义对其任意子节点均成立。</p><p><strong>1.1）树的构建</strong></p><p>一个平衡的k-d tree，其所有叶子节点到根节点的距离近似相等。但一个平衡的k-d tree对最近邻搜索、空间搜索等应用场景并非是最优的。</p><p>常规的k-d tree的构建过程为：循环依序取数据点的各维度来作为切分维度，取数据点在该维度的中值作为切分超平面，将中值左侧的数据点挂在其左子树，将中值右侧的数据点挂在其右子树。递归处理其子树，直至所有数据点挂载完毕。</p><p><strong>a）切分维度选择优化</strong></p><p>构建开始前，对比数据点在各维度的分布情况，数据点在某一维度坐标值的方差越大分布越分散，方差越小分布越集中。从方差大的维度开始切分可以取得很好的切分效果及平衡性。</p><p><strong>b）中值选择优化</strong></p><p>第一种，算法开始前，对原始数据点在所有维度进行一次排序，存储下来，然后在后续的中值选择中，无须每次都对其子集进行排序，提升了性能。</p><p>第二种，从原始数据点中随机选择固定数目的点，然后对其进行排序，每次从这些样本点中取中值，来作为分割超平面。该方式在实践中被证明可以取得很好性能及很好的平衡性。</p><p>本文采用常规的构建方式，以二维平面点<code>$(x,y)$</code>的集合(2,3)，(5,4)，(9,6)，(4,7)，(8,1)，(7,2)为例结合下图来说明k-d tree的构建过程。</p><p><strong>a）</strong> 构建根节点时，此时的切分维度为<code>$x$</code>，如上点集合在<code>$x$</code>维从小到大排序为(2,3)，(4,7)，(5,4)，(7,2)，(8,1)，(9,6)；其中值为(7,2)。（注：2,4,5,7,8,9在数学中的中值为(5 + 7)/2=6，但因该算法的中值需在点集合之内，所以本文中值计算用的是len(points)//2=3, points[3]=(7,2)）</p><p><strong>b）</strong> (2,3)，(4,7)，(5,4)挂在(7,2)节点的左子树，(8,1)，(9,6)挂在(7,2)节点的右子树。</p><p><strong>c）</strong> 构建(7,2)节点的左子树时，点集合(2,3)，(4,7)，(5,4)此时的切分维度为<code>$y$</code>，中值为(5,4)作为分割平面，(2,3)挂在其左子树，(4,7)挂在其右子树。</p><p><strong>d）</strong> 构建(7,2)节点的右子树时，点集合(8,1)，(9,6)此时的切分维度也为<code>$y$</code>，中值为(9,6)作为分割平面，(8,1)挂在其左子树。至此k-d tree构建完成。</p><p><img loading=lazy src=https://leileiluoluo.github.io/static/images/uploads/2017/12/kd-tree-building.png alt></p><p>上述的构建过程结合下图可以看出，构建一个k-d tree即是将一个二维平面逐步划分的过程。</p><p><img loading=lazy src=https://leileiluoluo.github.io/static/images/uploads/2017/12/kd-tree-building-pic.png alt></p><p>我们还可以结合下图（该图引自<a href=https://en.wikipedia.org/wiki/K-d_tree>维基百科</a>），从三维空间来看一下k-d tree的构建及空间划分过程。</p><p>首先，边框为红色的竖直平面将整个空间划分为两部分，此两部分又分别被边框为绿色的水平平面划分为上下两部分。最后此4个子空间又分别被边框为蓝色的竖直平面分割为两部分，变为8个子空间，此8个子空间即为叶子节点。</p><p><img loading=lazy src=https://leileiluoluo.github.io/static/images/uploads/2017/12/3d-tree-space-patitioning.png alt></p><p>如下为k-d tree的构建代码：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000;font-weight:700>def</span> <span style=color:#900;font-weight:700>kd_tree</span>(points, depth):
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> <span style=color:#099>0</span> <span style=color:#000;font-weight:700>==</span> <span style=color:#0086b3>len</span>(points):
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>None</span>
</span></span><span style=display:flex><span>    cutting_dim <span style=color:#000;font-weight:700>=</span> depth <span style=color:#000;font-weight:700>%</span> <span style=color:#0086b3>len</span>(points[<span style=color:#099>0</span>])
</span></span><span style=display:flex><span>    medium_index <span style=color:#000;font-weight:700>=</span> <span style=color:#0086b3>len</span>(points) <span style=color:#000;font-weight:700>//</span> <span style=color:#099>2</span>
</span></span><span style=display:flex><span>    points<span style=color:#000;font-weight:700>.</span>sort(key<span style=color:#000;font-weight:700>=</span>itemgetter(cutting_dim))
</span></span><span style=display:flex><span>    node <span style=color:#000;font-weight:700>=</span> Node(points[medium_index])
</span></span><span style=display:flex><span>    node<span style=color:#000;font-weight:700>.</span>left <span style=color:#000;font-weight:700>=</span> kd_tree(points[:medium_index], depth <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>)
</span></span><span style=display:flex><span>    node<span style=color:#000;font-weight:700>.</span>right <span style=color:#000;font-weight:700>=</span> kd_tree(points[medium_index <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>:], depth <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>return</span> node
</span></span></code></pre></div><p><strong>1.2）寻找d维最小坐标值点</strong></p><p><strong>a）若当前节点的切分维度是d</strong></p><p>因其右子树节点均大于等于当前节点在d维的坐标值，所以可以忽略其右子树，仅在其左子树进行搜索。若无左子树，当前节点即是最小坐标值节点。</p><p><strong>b）若当前节点的切分维度不是d</strong></p><p>需在其左子树与右子树分别进行递归搜索。</p><p>如下为寻找d维最小坐标值点代码：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000;font-weight:700>def</span> <span style=color:#900;font-weight:700>findmin</span>(n, depth, cutting_dim, <span style=color:#0086b3>min</span>):
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>min</span> <span style=color:#000;font-weight:700>is</span> <span style=color:#000;font-weight:700>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#0086b3>min</span> <span style=color:#000;font-weight:700>=</span> n<span style=color:#000;font-weight:700>.</span>location
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> n <span style=color:#000;font-weight:700>is</span> <span style=color:#000;font-weight:700>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>return</span> <span style=color:#0086b3>min</span>
</span></span><span style=display:flex><span>    current_cutting_dim <span style=color:#000;font-weight:700>=</span> depth <span style=color:#000;font-weight:700>%</span> <span style=color:#0086b3>len</span>(<span style=color:#0086b3>min</span>)
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> n<span style=color:#000;font-weight:700>.</span>location[cutting_dim] <span style=color:#000;font-weight:700>&lt;</span> <span style=color:#0086b3>min</span>[cutting_dim]:
</span></span><span style=display:flex><span>        <span style=color:#0086b3>min</span> <span style=color:#000;font-weight:700>=</span> n<span style=color:#000;font-weight:700>.</span>location
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> cutting_dim <span style=color:#000;font-weight:700>==</span> current_cutting_dim:
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>return</span> findmin(n<span style=color:#000;font-weight:700>.</span>left, depth <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>, cutting_dim, <span style=color:#0086b3>min</span>)
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>else</span>:
</span></span><span style=display:flex><span>        leftmin <span style=color:#000;font-weight:700>=</span> findmin(n<span style=color:#000;font-weight:700>.</span>left, depth <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>, cutting_dim, <span style=color:#0086b3>min</span>)
</span></span><span style=display:flex><span>        rightmin <span style=color:#000;font-weight:700>=</span> findmin(n<span style=color:#000;font-weight:700>.</span>right, depth <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>, cutting_dim, <span style=color:#0086b3>min</span>)
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>if</span> leftmin[cutting_dim] <span style=color:#000;font-weight:700>&gt;</span> rightmin[cutting_dim]:
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>return</span> rightmin
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#000;font-weight:700>return</span> leftmin
</span></span></code></pre></div><p><strong>1.3）新增节点</strong></p><p>从根节点出发，若待插入节点在当前节点切分维度的坐标值小于当前节点在该维度的坐标值时，在其左子树插入；若大于等于当前节点在该维度的坐标值时，在其右子树插入。递归遍历，直至叶子节点。</p><p>如下为新增节点代码：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000;font-weight:700>def</span> <span style=color:#900;font-weight:700>insert</span>(n, point, depth):
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> n <span style=color:#000;font-weight:700>is</span> <span style=color:#000;font-weight:700>None</span>:
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>return</span> Node(point)
</span></span><span style=display:flex><span>    cutting_dim <span style=color:#000;font-weight:700>=</span> depth <span style=color:#000;font-weight:700>%</span> <span style=color:#0086b3>len</span>(point)
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> point[cutting_dim] <span style=color:#000;font-weight:700>&lt;</span> n<span style=color:#000;font-weight:700>.</span>location[cutting_dim]:
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>if</span> n<span style=color:#000;font-weight:700>.</span>left <span style=color:#000;font-weight:700>is</span> <span style=color:#000;font-weight:700>None</span>:
</span></span><span style=display:flex><span>            n<span style=color:#000;font-weight:700>.</span>left <span style=color:#000;font-weight:700>=</span> Node(point)
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>else</span>:
</span></span><span style=display:flex><span>            insert(n<span style=color:#000;font-weight:700>.</span>left, point, depth <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>if</span> n<span style=color:#000;font-weight:700>.</span>right <span style=color:#000;font-weight:700>is</span> <span style=color:#000;font-weight:700>None</span>:
</span></span><span style=display:flex><span>            n<span style=color:#000;font-weight:700>.</span>right <span style=color:#000;font-weight:700>=</span> Node(point)
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>else</span>:
</span></span><span style=display:flex><span>            insert(n<span style=color:#000;font-weight:700>.</span>right, point, depth <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>)
</span></span></code></pre></div><p>多次新增节点可能引起树的不平衡。不平衡性超过某一阈值时，需进行再平衡。</p><p><strong>1.4）删除节点</strong></p><p>最简单的方法是将待删节点的所有子节点组成一个新的集合，然后对其进行重新构建。将构建好的子树挂载到被删节点即可。此方法性能不佳，下面考虑优化后的算法。</p><p>假设待删节点T的切分维度为x，下面根据待删节点的几类不同情形进行考虑。</p><p><strong>a）无子树</strong></p><p>本身为叶子节点，直接删除。</p><p><strong>b）有右子树</strong></p><p>在T.right寻找x切分维度最小的节点p，然后替换被删节点T；递归处理删除节点p。</p><p><strong>c）无右子树有左子树</strong></p><p>在T.left寻找x切分维度最小的节点p，即p=findmin(T.left, cutting-dim=x)，然后用节点p替换被删节点T；将原T.left作为p.right；递归处理删除节点p。</p><p>（之所以未采用findmax(T.left, cutting-dim=x)节点来替换被删节点，是由于原被删节点的左子树节点存在x维度最大值相等的情形，这样就破坏了左子树在x分割维度的坐标需小于其根节点的定义）</p><p>如下为删除节点代码：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#000;font-weight:700>def</span> <span style=color:#900;font-weight:700>delete</span>(n, point, depth):
</span></span><span style=display:flex><span>    cutting_dim <span style=color:#000;font-weight:700>=</span> depth <span style=color:#000;font-weight:700>%</span> <span style=color:#0086b3>len</span>(point)
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>if</span> n<span style=color:#000;font-weight:700>.</span>location <span style=color:#000;font-weight:700>==</span> point:
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>if</span> n<span style=color:#000;font-weight:700>.</span>right <span style=color:#000;font-weight:700>is</span> <span style=color:#000;font-weight:700>not</span> <span style=color:#000;font-weight:700>None</span>:
</span></span><span style=display:flex><span>            n<span style=color:#000;font-weight:700>.</span>location <span style=color:#000;font-weight:700>=</span> findmin(n<span style=color:#000;font-weight:700>.</span>right, depth <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>, cutting_dim, <span style=color:#000;font-weight:700>None</span>)
</span></span><span style=display:flex><span>            delete(n<span style=color:#000;font-weight:700>.</span>right, n<span style=color:#000;font-weight:700>.</span>location, depth <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>elif</span> n<span style=color:#000;font-weight:700>.</span>left <span style=color:#000;font-weight:700>is</span> <span style=color:#000;font-weight:700>not</span> <span style=color:#000;font-weight:700>None</span>:
</span></span><span style=display:flex><span>            n<span style=color:#000;font-weight:700>.</span>location <span style=color:#000;font-weight:700>=</span> findmin(n<span style=color:#000;font-weight:700>.</span>left, depth <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>)
</span></span><span style=display:flex><span>            delete(n<span style=color:#000;font-weight:700>.</span>left, n<span style=color:#000;font-weight:700>.</span>location, depth <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>)
</span></span><span style=display:flex><span>            n<span style=color:#000;font-weight:700>.</span>right <span style=color:#000;font-weight:700>=</span> n<span style=color:#000;font-weight:700>.</span>left
</span></span><span style=display:flex><span>            n<span style=color:#000;font-weight:700>.</span>left <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>None</span>
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>else</span>:
</span></span><span style=display:flex><span>            n <span style=color:#000;font-weight:700>=</span> <span style=color:#000;font-weight:700>None</span>
</span></span><span style=display:flex><span>    <span style=color:#000;font-weight:700>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>if</span> point[cutting_dim] <span style=color:#000;font-weight:700>&lt;</span> n<span style=color:#000;font-weight:700>.</span>location[cutting_dim]:
</span></span><span style=display:flex><span>            delete(n<span style=color:#000;font-weight:700>.</span>left, point, depth <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#000;font-weight:700>else</span>:
</span></span><span style=display:flex><span>            delete(n<span style=color:#000;font-weight:700>.</span>right, point, depth <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>)
</span></span></code></pre></div><p><strong>2）最近邻搜索</strong></p><p>给定点p，查询数据集中与其距离最近点的过程即为最近邻搜索。</p><p>如在上文构建好的k-d tree上搜索(3,5)的最近邻时，本文结合如下左右两图对二维空间的最近邻搜索过程作分析。</p><p><strong>a）</strong> 首先从根节点(7,2)出发，将当前最近邻设为(7,2)，对该k-d tree作深度优先遍历。以(3,5)为圆心，其到(7,2)的距离为半径画圆（多维空间为超球面），可以看出(8,1)右侧的区域与该圆不相交，所以(8,1)的右子树全部忽略。</p><p><strong>b）</strong> 接着走到(7,2)左子树根节点(5,4)，与原最近邻对比距离后，更新当前最近邻为(5,4)。以(3,5)为圆心，其到(5,4)的距离为半径画圆，发现(7,2)右侧的区域与该圆不相交，忽略该侧所有节点，这样(7,2)的整个右子树被标记为已忽略。</p><p><strong>c）</strong> 遍历完(5,4)的左右叶子节点，发现与当前最优距离相等，不更新最近邻。所以(3,5)的最近邻为(5,4)。</p><p><img loading=lazy src=https://leileiluoluo.github.io/static/images/uploads/2017/12/nn-searching-in-2d-space.png alt></p><p><img loading=lazy src=https://leileiluoluo.github.io/static/images/uploads/2017/12/nn-searching-in-kd-tree.png alt></p><p>如下为最近邻搜索代码：</p><p><strong>3）复杂度分析</strong></p><pre tabindex=0><code>操作	平均复杂度	最坏复杂度
新增节点	O(logn)	O(n)
删除节点	O(logn)	O(n)
最近邻搜索	O(logn)	O(n)
</code></pre><p><strong>4）scikit-learn使用</strong></p><p>scikit-learn是一个实用的机器学习类库，其有KDTree的实现。如下例子为直观展示，仅构建了一个二维空间的k-d tree，然后对其作k近邻搜索及指定半径的范围搜索。多维空间的检索，调用方式与此例相差无多。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#998;font-style:italic>#!/usr/bin/python</span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic># -*- coding: UTF-8 -*-</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>import</span> <span style=color:#555>numpy</span> <span style=color:#000;font-weight:700>as</span> <span style=color:#555>np</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>from</span> <span style=color:#555>matplotlib</span> <span style=color:#000;font-weight:700>import</span> pyplot <span style=color:#000;font-weight:700>as</span> plt
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>from</span> <span style=color:#555>matplotlib.patches</span> <span style=color:#000;font-weight:700>import</span> Circle
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>from</span> <span style=color:#555>sklearn.neighbors</span> <span style=color:#000;font-weight:700>import</span> KDTree
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>np<span style=color:#000;font-weight:700>.</span>random<span style=color:#000;font-weight:700>.</span>seed(<span style=color:#099>0</span>)
</span></span><span style=display:flex><span>points <span style=color:#000;font-weight:700>=</span> np<span style=color:#000;font-weight:700>.</span>random<span style=color:#000;font-weight:700>.</span>random((<span style=color:#099>100</span>, <span style=color:#099>2</span>))
</span></span><span style=display:flex><span>tree <span style=color:#000;font-weight:700>=</span> KDTree(points)
</span></span><span style=display:flex><span>point <span style=color:#000;font-weight:700>=</span> points[<span style=color:#099>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic># kNN</span>
</span></span><span style=display:flex><span>dists, indices <span style=color:#000;font-weight:700>=</span> tree<span style=color:#000;font-weight:700>.</span>query([point], k<span style=color:#000;font-weight:700>=</span><span style=color:#099>3</span>)
</span></span><span style=display:flex><span><span style=color:#0086b3>print</span>(dists, indices)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic># query radius</span>
</span></span><span style=display:flex><span>indices <span style=color:#000;font-weight:700>=</span> tree<span style=color:#000;font-weight:700>.</span>query_radius([point], r<span style=color:#000;font-weight:700>=</span><span style=color:#099>0.2</span>)
</span></span><span style=display:flex><span><span style=color:#0086b3>print</span>(indices)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fig <span style=color:#000;font-weight:700>=</span> plt<span style=color:#000;font-weight:700>.</span>figure()
</span></span><span style=display:flex><span>ax <span style=color:#000;font-weight:700>=</span> fig<span style=color:#000;font-weight:700>.</span>add_subplot(<span style=color:#099>111</span>, aspect<span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#39;equal&#39;</span>)
</span></span><span style=display:flex><span>ax<span style=color:#000;font-weight:700>.</span>add_patch(Circle(point, <span style=color:#099>0.2</span>, color<span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#39;r&#39;</span>, fill<span style=color:#000;font-weight:700>=</span><span style=color:#000;font-weight:700>False</span>))
</span></span><span style=display:flex><span>X, Y <span style=color:#000;font-weight:700>=</span> [p[<span style=color:#099>0</span>] <span style=color:#000;font-weight:700>for</span> p <span style=color:#000;font-weight:700>in</span> points], [p[<span style=color:#099>1</span>] <span style=color:#000;font-weight:700>for</span> p <span style=color:#000;font-weight:700>in</span> points]
</span></span><span style=display:flex><span>plt<span style=color:#000;font-weight:700>.</span>scatter(X, Y)
</span></span><span style=display:flex><span>plt<span style=color:#000;font-weight:700>.</span>scatter([point[<span style=color:#099>0</span>]], [point[<span style=color:#099>1</span>]], c<span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#39;r&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#000;font-weight:700>.</span>show()
</span></span></code></pre></div><p><img loading=lazy src=https://leileiluoluo.github.io/static/images/uploads/2017/12/scikit-learn-kd-tree.png alt></p><blockquote><p>参考资料</p><p>[1] <a href=https://en.wikipedia.org/wiki/K-d_tree>https://en.wikipedia.org/wiki/K-d_tree</a></p><p>[2] <a href=https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/kdtrees.pdf>https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/kdtrees.pdf</a></p><p>[3] <a href=https://www.cise.ufl.edu/class/cot5520fa09/CG_RangeKDtrees.pdf>https://www.cise.ufl.edu/class/cot5520fa09/CG_RangeKDtrees.pdf</a></p><p>[4] <a href=http://www.cs.cornell.edu/courses/cs4780/2017sp/lectures/lecturenote16.html>http://www.cs.cornell.edu/courses/cs4780/2017sp/lectures/lecturenote16.html</a></p><p>[5] <a href=https://rosettacode.org/wiki/K-d_tree>https://rosettacode.org/wiki/K-d_tree</a></p><p>[6] <a href=http://prody.csb.pitt.edu/_modules/prody/kdtree/kdtree.html#KDTree>http://prody.csb.pitt.edu/_modules/prody/kdtree/kdtree.html</a></p><p>[7] <a href=http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KDTree.html>http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KDTree.html</a></p><p>[8] <a href=http://www.dcc.fc.up.pt/~pribeiro/aulas/taa1516/rangesearch.pdf>http://www.dcc.fc.up.pt/~pribeiro/aulas/taa1516/rangesearch.pdf</a></p><p>[9] <a href=https://courses.cs.washington.edu/courses/cse373/02au/lectures/lecture22l.pdf>https://courses.cs.washington.edu/courses/cse373/02au/lectures/lecture22l.pdf</a></p><p>[10] <a href=http://www.cs.princeton.edu/courses/archive/spr13/cos226/lectures/99GeometricSearch.pdf>http://www.cs.princeton.edu/courses/archive/spr13/cos226/lectures/99GeometricSearch.pdf</a></p><p>[11] <a href=http://www.cs.umd.edu/class/spring2002/cmsc420-0401/pbasic.pdf>http://www.cs.umd.edu/class/spring2002/cmsc420-0401/pbasic.pdf</a></p><p>[12] <a href=https://www.ri.cmu.edu/pub_files/pub1/moore_andrew_1991_1/moore_andrew_1991_1.pdf>https://www.ri.cmu.edu/pub_files/pub1/moore_andrew_1991_1/moore_andrew_1991_1.pdf</a></p></blockquote></div><div class=content-footer><div class=weixinhao><img src=/static/images/self/weixinhao-white.jpg></div><div class=post-tags><a href=/tags/python/>#Python</a>
<a href=/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/>#机器学习</a>
<a href=/tags/%E7%AE%97%E6%B3%95/>#算法</a></div><div class=license><i class=ti-info-alt></i><div class=info>版权声明：该博客文章由作者通过「<a href=https://creativecommons.org/licenses/by/4.0/deed.zh>知识共享署名 4.0 许可证</a>」进行授权，转载须注明文章原始链接。</div></div></div></div><div class="col-lg-8 mx-auto block shadow"><h3>相关文章</h3><ul><li><a href=/posts/perceptron-python-implementation.html>感知机算法及 Python 实现</a></li><li><a href=/posts/leetcode-construct-binary-tree-from-preorder-and-inorder-traversal.html>LeetCode 105 以先序遍历及中序遍历构造二叉树</a></li><li><a href=/posts/leetcode-design-linked-list.html>LeetCode 707 设计链表</a></li><li><a href=/leetcode-golang-implementations/>LeetCode 题目Golang实现汇总</a></li><li><a href=/posts/consistent-hashing-and-high-available-cluster-proxy.html>一致性哈希算法与高可用集群代理</a></li></ul></div><div class="col-lg-8 mx-auto block shadow"><div><h3>评论</h3><div id=comment-loading style=text-align:center;font-size:14px><img style=width:52px src=/static/images/site/mona-loading-default.gif>
<span>正在加载评论......</span></div><script>function handleMessage(e){if(e.origin!=="https://giscus.app")return;if(typeof e.data!="object"||!e.data.giscus)return;const t=document.getElementById("comment-loading");t.style.display="none"}window.addEventListener("message",handleMessage)</script><script src=https://giscus.app/client.js data-repo=leileiluoluo/leileiluoluo.github.io data-repo-id=R_kgDOJkLT8w data-category=General data-category-id=DIC_kwDOJkLT884CdtEh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></div></div></div></section><footer class="py-4 bg-lights border-top"><div class=container><div class="row justify-content-between text-center align-items-center"><div class="col-lg-4 text-center text-lg-left mb-4 mb-lg-0"></div><div class="col-lg-4 text-center mb-4 mb-lg-0"><ul class="list-inline mb-0"><li class=list-inline-item><a class="text-dark d-block p-2" href=https://leileiluoluo.github.io/sponsor>随喜打赏</a></li><li class=list-inline-item><a class="text-dark d-block p-2" href=https://leileiluoluo.github.io/about>关于本博</a></li><li class=list-inline-item><a class="text-dark d-block p-2" href=https://leileiluoluo.github.io/links>友情链接</a></li></ul></div><div class="col-lg-4 text-lg-right text-center mb-4 mb-lg-0"><ul class="list-inline social-icon mb-0"><li class=list-inline-item><a title=文章归档 href=/archives/><i class=ti-archive></i></a></li><li class=list-inline-item><a title=文章标签 href=/tags/><i class=ti-tag></i></a></li><li class=list-inline-item><a title="我的 GitHub" href=https://github.com/leileiluoluo><i class=ti-github></i></a></li><li class=list-inline-item><a title="网站 RSS" href=/index.xml><i class=ti-rss></i></a></li></ul></div></div><div style=text-align:center;font-size:18px;margin-bottom:22px><a style="-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-image:linear-gradient(to right,#14100f,#d55b5b,#4d14e6)" href=https://www.boyouquan.com/planet-shuttle>「博友圈 · 星球穿梭」</a></div><div class="text-center mt-4"><span>Made with <a href=https://gohugo.io/>Hugo</a> | Theme by <a href=https://github.com/themefisher/northendlab-hugo>NorthendLab</a> | <a href=https://beian.miit.gov.cn>辽ICP备2022012085号-5</a> | Copyright © 2017-2025</span></div></div></footer><script>var indexURL="https://leileiluoluo.github.io/index.json"</script><script src=https://leileiluoluo.github.io/js/jquery.min.js></script><script src=https://leileiluoluo.github.io/js/bootstrap.min.js></script><script src=https://leileiluoluo.github.io/js/fuse.min.js></script><script src=https://leileiluoluo.github.io/js/mark.js></script><script src=https://leileiluoluo.github.io/js/search.js></script><script src=https://leileiluoluo.github.io/js/script.min.js></script></body></html>